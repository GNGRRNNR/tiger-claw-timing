<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiger Claw Live Results (Unofficial)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        th, td { padding: 0.5rem 0.5rem; text-align: left; border-bottom: 1px solid #e5e7eb; border-right: 1px solid #f3f4f6; white-space: nowrap; }
        th:last-child, td:last-child { border-right: none; }
        th { background-color: #f9fafb; font-weight: 600; user-select: none; }
        th[data-sort] { cursor: pointer; }
        th .sort-icon { display: inline-block; width: 1em; height: 1em; margin-left: 0.3em; opacity: 0.3; vertical-align: middle;}
        th.sort-asc .sort-icon::after { content: ' ‚ñ≤'; }
        th.sort-desc .sort-icon::after { content: ' ‚ñº'; }
        tbody tr:nth-child(even) { background-color: #f9fafb; }
        tbody tr:hover { background-color: #f0f9ff; }
        .status-active { color: #059669; font-weight: 500; } .status-finished { color: #1d4ed8; font-weight: 500; } .status-dnf, .status-dns { color: #dc2626; font-weight: 500; }
        .loop-pink { background-color: #fce7f3; color: #831843; padding: 0.1rem 0.4rem; border-radius: 0.25rem; font-size: 0.75rem; display: inline-block; margin: 0.1rem; }
        .loop-white { background-color: #f1f5f9; color: #1e293b; padding: 0.1rem 0.4rem; border-radius: 0.25rem; font-size: 0.75rem; display: inline-block; margin: 0.1rem; border: 1px solid #cbd5e1;}
        .loop-yellow { background-color: #fef9c3; color: #713f12; padding: 0.1rem 0.4rem; border-radius: 0.25rem; font-size: 0.75rem; display: inline-block; margin: 0.1rem; }
        #loadingMessage, #errorMessage { text-align: center; padding: 1rem; font-weight: 500; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #4f46e5; border-radius: 50%; width: 1em; height: 1em; animation: spin 1s linear infinite; display: inline-block; margin: 0 0.5rem; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        thead th { position: sticky; top: 0; z-index: 10; background-color: #f9fafb; }
        .hidden { display: none; }
        /* Tab styles */
        .tab-button { padding: 0.5rem 1rem; margin-right: 0.5rem; border: 1px solid transparent; border-bottom: none; border-radius: 0.375rem 0.375rem 0 0; cursor: pointer; background-color: #e5e7eb; color: #4b5563; }
        .tab-button.active { background-color: white; color: #1f2937; border-color: #e5e7eb; font-weight: 600; }
        .tab-content { border: 1px solid #e5e7eb; border-top: none; padding-top: 1rem; }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="container mx-auto bg-white p-6 rounded-lg shadow-lg">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-1">Tiger Claw Live Results</h1>
        <p class="text-lg text-center text-gray-600 mb-4">(Unofficial)</p>
        <p class="text-center text-xs text-gray-500 mb-2">
            Last Updated: <span id="lastUpdated">Never</span>
            <span id="loadingSpinner" class="spinner hidden"></span>
        </p>
        <p class="text-center text-xs text-gray-500 mb-6">
            <span title="Big Cat Challenge (Ascent + 50k)">üêÖ</span> = Big Cat Challenge Participant
        </p>
        <div class="mb-4 border-b border-gray-200">
            <nav class="-mb-px flex flex-wrap" aria-label="Tabs">
                <button id="tabButton50k" type="button" class="tab-button active" data-target="results50k">50k</button>
                <button id="tabButtonAscent" type="button" class="tab-button" data-target="resultsAscent">Ascent</button>
                <button id="tabButtonBigCat" type="button" class="tab-button" data-target="resultsBigCat">Big Cat</button>
            </nav>
        </div>

        <div class="mb-4">
            <label for="searchInput" class="sr-only">Search by Bib or Name:</label>
            <input type="text" id="searchInput" placeholder="Search by Bib or Name..." class="w-full md:w-1/2 lg:w-1/3 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
        </div>

        <div id="loadingMessage" class="text-gray-600">
             <div>Loading initial results...</div>
        </div>
        <div id="errorMessage" class="text-red-600 hidden">
            Error loading results. Please try refreshing the page.
            <pre id="errorDetails" class="text-xs text-left mt-2 bg-red-50 p-2 rounded"></pre>
        </div>

        <div id="tabContent">
            <div id="results50k" class="tab-content">
                <div id="resultsTableContainer50k" class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200 border border-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="bib">Bib<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="name">Name<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="status">Status<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="green_cp">Green CP<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Lp 1</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">L1 Bot</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">L1 Top</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">L1 Elapsed</th> <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">D1 Elapsed</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Lp 2</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">L2 Bot</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">L2 Top</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">L2 Elapsed</th> <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">D2 Elapsed</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Lp 3</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">L3 Bot</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">L3 Top</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">L3 Elapsed</th> <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">D3 Elapsed</th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="red_cp">Red CP<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="finish_scan">Finish Scan<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="finish_elapsed">Total Time<span class="sort-icon"></span></th>
                            </tr>
                        </thead>
                        <tbody id="resultsBody50k" class="bg-white divide-y divide-gray-200"></tbody>
                    </table>
                </div>
                 <p id="rowCount50k" class="text-xs text-gray-500 mt-2"></p>
            </div>

             <div id="resultsAscent" class="tab-content hidden">
                 <div id="resultsTableContainerAscent" class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200 border border-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="bib">Bib<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="name">Name<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="status">Status<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="finish_scan">Finish Scan<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="finish_elapsed">Elapsed Time<span class="sort-icon"></span></th>
                            </tr>
                        </thead>
                        <tbody id="resultsBodyAscent" class="bg-white divide-y divide-gray-200"></tbody>
                    </table>
                </div>
                 <p id="rowCountAscent" class="text-xs text-gray-500 mt-2"></p>
            </div>

            <div id="resultsBigCat" class="tab-content hidden">
                 <div id="resultsTableContainerBigCat" class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200 border border-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="name">Name<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="ascent_elapsed">Ascent Time<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="fiftyk_elapsed">50k Time<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-sort="cumulative_elapsed">Cumulative Time<span class="sort-icon"></span></th>
                                <th scope="col" class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            </tr>
                        </thead>
                        <tbody id="resultsBodyBigCat" class="bg-white divide-y divide-gray-200"></tbody>
                    </table>
                </div>
                 <p id="rowCountBigCat" class="text-xs text-gray-500 mt-2"></p>
            </div>
            </div>

    </div>

    <script>
        // --- Configuration ---
        const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbznjmZnmSIhxIjpcAey4veFhYiP7-KR5lnbBR8VfkrwrOxk_lIzZ31BK62AvdAmli8/exec'; // <-- URL for Tiger Claw Scan Receiver Script
        const RESULTS_50K_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTHGEvgy3yNGS0uV48XNrMGnbbZNorOFTx6YO0Q7dwrGkgvCkAYt2p6644uScSDqee14uVB8-0xhSGy/pub?gid=1613674231&single=true&output=csv';
        const RESULTS_ASCENT_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTHGEvgy3yNGS0uV48XNrMGnbbZNorOFTx6YO0Q7dwrGkgvCkAYt2p6644uScSDqee14uVB8-0xhSGy/pub?gid=619464822&single=true&output=csv';
        const REFRESH_INTERVAL_MS = 45 * 1000;
        const RACE_START_TIME_50K_MS = Date.UTC(2025, 4, 10, 14, 0, 0); // May 10, 2025 7:00 AM PST
        const RACE_START_TIME_ASCENT_MS = Date.UTC(2025, 4, 9, 18 + 7, 0, 0); // May 9, 2025 6:00 PM PST (PST=UTC-7 during DST)
        const COL_50K = { BIB: 0, NAME: 1, STATUS: 2, GREEN_CP: 3, LOOP1_COLOR: 4, LOOP1_BOTTOM: 5, LOOP1_TOP: 6, LOOP1_ELAPSED: 7, DESC1_ELAPSED: 8, LOOP2_COLOR: 9, LOOP2_BOTTOM: 10, LOOP2_TOP: 11, LOOP2_ELAPSED: 12, DESC2_ELAPSED: 13, LOOP3_COLOR: 14, LOOP3_BOTTOM: 15, LOOP3_TOP: 16, LOOP3_ELAPSED: 17, DESC3_ELAPSED: 18, RED_CP: 19, FINISH_SCAN: 20, FINISH_ELAPSED: 21 };
        const COL_ASCENT = { BIB: 0, NAME: 1, STATUS: 2, FINISH_SCAN: 3, FINISH_ELAPSED: 4 };
        // --- End Configuration ---

        // --- DOM Elements ---
        const resultsBody50k = document.getElementById('resultsBody50k');
        const resultsBodyAscent = document.getElementById('resultsBodyAscent');
        const resultsBodyBigCat = document.getElementById('resultsBodyBigCat');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorMessage = document.getElementById('errorMessage');
        const errorDetails = document.getElementById('errorDetails');
        const resultsTableContainer50k = document.getElementById('resultsTableContainer50k');
        const resultsTableContainerAscent = document.getElementById('resultsTableContainerAscent');
        const resultsTableContainerBigCat = document.getElementById('resultsTableContainerBigCat');
        const lastUpdatedElement = document.getElementById('lastUpdated');
        const searchInput = document.getElementById('searchInput');
        const rowCount50kElement = document.getElementById('rowCount50k');
        const rowCountAscentElement = document.getElementById('rowCountAscent');
        const rowCountBigCatElement = document.getElementById('rowCountBigCat');
        const tableHeaders50k = document.querySelectorAll('#resultsTableContainer50k th[data-sort]');
        const tableHeadersAscent = document.querySelectorAll('#resultsTableContainerAscent th[data-sort]');
        const tableHeadersBigCat = document.querySelectorAll('#resultsTableContainerBigCat th[data-sort]');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const tabButton50k = document.getElementById('tabButton50k');
        const tabButtonAscent = document.getElementById('tabButtonAscent');
        const tabButtonBigCat = document.getElementById('tabButtonBigCat');
        const results50kDiv = document.getElementById('results50k');
        const resultsAscentDiv = document.getElementById('resultsAscent');
        const resultsBigCatDiv = document.getElementById('resultsBigCat');

        // --- App State ---
        let refreshIntervalId = null;
        let all50kDataFromCSV = []; let allAscentResultsFromCSV = [];
        let calculated50kData = []; let calculatedAscentData = [];
        let calculatedBigCatData = [];
        let all50kRunnerList = []; let allAscentRunnerList = [];
        let all50kRunnerNames = new Set(); let allAscentRunnerNames = new Set();
        let dualRunnerNames = new Set();
        let currentSort = { column: 'bib', direction: 'asc' };
        let currentFilter = '';
        let isFetching = false;
        let activeTab = '50k';

        // --- Utility Functions ---
        function parseCSV(csvText) { if (!csvText || typeof csvText !== 'string') return []; const lines = csvText.trim().split('\n'); return lines.slice(1).map(line => line.split(',').map(field => field.trim())); }
        function formatTime(dateTimeString) { if (!dateTimeString || dateTimeString.trim() === "") return ""; try { const date = new Date(dateTimeString); if (isNaN(date.getTime()) || date.getFullYear() < 1900) return ""; return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', second: '2-digit' }); } catch (e) { return ""; } }
        function formatMillisecondsToDuration(ms) { if (ms === undefined || ms === null || isNaN(Number(ms)) || Number(ms) < 0) return ""; try { const totalMilliseconds = Number(ms); if (totalMilliseconds < 500) return "00:00:00"; const totalSeconds = Math.floor(totalMilliseconds / 1000); const hours = Math.floor(totalSeconds / 3600); const minutes = Math.floor((totalSeconds % 3600) / 60); const seconds = totalSeconds % 60; return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; } catch (e) { console.error("Error formatting milliseconds:", ms, e); return "Invalid"; } }
        function formatDurationFromCSV(durationInput) { if (durationInput === undefined || durationInput === null) return ""; const durationString = String(durationInput).trim(); if (durationString === "" || durationString.startsWith('-')) { return ""; } const numericValue = parseFloat(durationString); if (!isNaN(numericValue) && numericValue > 0 && numericValue < 100) { try { const ms = numericValue * 24 * 60 * 60 * 1000; return formatMillisecondsToDuration(ms); } catch (e) { return "Invalid"; } } else if (/^\d{1,3}:\d{2}:\d{2}(\.\d+)?$/.test(durationString)) { try { const parts = durationString.split(':'); const h = String(parts[0] || '0').padStart(2, '0'); const m = String(parts[1] || '0').padStart(2, '0'); const s = String(Math.floor(parseFloat(parts[2] || '0'))).padStart(2, '0'); return `${h}:${m}:${s}`; } catch(e) { return "Invalid"; } } else { return ""; } }
        function getStatusClass(status) { status = status.toUpperCase(); if (status === 'FINISHED') return 'status-finished'; if (status === 'DNF' || status === 'DNS') return 'status-dnf'; if (status === 'ACTIVE') return 'status-active'; return ''; }
        function createLoopSpan(color) { if (!color) return ''; color = color.toUpperCase(); let className = ''; if (color === 'PINK') className = 'loop-pink'; else if (color === 'WHITE') className = 'loop-white'; else if (color === 'YELLOW') className = 'loop-yellow'; else return ''; return `<span class="${className}">${color.substring(0,1)}</span>`; }
        function getTimeMs(dateString) { if (!dateString) return null; try { const date = new Date(dateString); return isNaN(date.getTime()) ? null : date.getTime(); } catch { return null; } }
        function normalizeName(name) { return String(name || '').trim().toUpperCase(); }

        // --- Data Processing Functions ---
        // ****** RESTORED processData to calculate all durations in JS ******
        function processData(rawData, raceType) {
             console.log(`Processing ${raceType} raw data (JS will calculate all durations)...`);
             const COL_MAP = raceType === '50k' ? COL_50K : COL_ASCENT;
             const START_TIME = raceType === '50k' ? RACE_START_TIME_50K_MS : RACE_START_TIME_ASCENT_MS;

             // For Ascent, we build from the full runner list and merge CSV results
             if (raceType === 'Ascent') {
                 return allAscentRunnerList.map(runnerFromList => {
                    const resultEntry = Array(Object.keys(COL_ASCENT).length).fill('');
                    resultEntry[COL_ASCENT.BIB] = runnerFromList.bib;
                    resultEntry[COL_ASCENT.NAME] = runnerFromList.name;

                    const finisherDataCSVRow = rawData.find(csvRow => String(csvRow[COL_ASCENT.BIB]).trim() === String(runnerFromList.bib).trim());

                    let finishScanTime = null;
                    let finishElapsedMs = null;

                    if (finisherDataCSVRow) {
                        finishScanTime = finisherDataCSVRow[COL_ASCENT.FINISH_SCAN];
                        resultEntry[COL_ASCENT.FINISH_SCAN] = finishScanTime;
                        const finishScanMsFromCSV = getTimeMs(finishScanTime);
                        if (finishScanMsFromCSV && finishScanMsFromCSV > START_TIME) {
                            finishElapsedMs = finishScanMsFromCSV - START_TIME;
                        }
                        resultEntry[COL_ASCENT.FINISH_ELAPSED] = finishElapsedMs;
                        resultEntry[COL_ASCENT.STATUS] = finisherDataCSVRow[COL_ASCENT.STATUS] || "FINISHED"; // Use status from CSV if available
                    } else {
                        resultEntry[COL_ASCENT.STATUS] = runnerFromList.status || "Active";
                    }
                    // Override with DNS/DNF from master list
                    if (runnerFromList.status && (runnerFromList.status.toUpperCase() === "DNS" || runnerFromList.status.toUpperCase() === "DNF")) {
                        resultEntry[COL_ASCENT.STATUS] = runnerFromList.status.toUpperCase();
                    }
                    return resultEntry;
                });
             }

             // For 50k, process the CSV data directly
             return rawData.map(row => {
                const bib = row[COL_MAP.BIB] || '';
                const processed = [...row];
                const finishScanMs = getTimeMs(row[COL_MAP.FINISH_SCAN]);
                let totalElapsedMs = null;
                if (finishScanMs && finishScanMs > START_TIME) {
                    totalElapsedMs = finishScanMs - START_TIME;
                }
                processed[COL_MAP.FINISH_ELAPSED] = totalElapsedMs;

                const l1BotMs = getTimeMs(row[COL_MAP.LOOP1_BOTTOM]); const l1TopMs = getTimeMs(row[COL_MAP.LOOP1_TOP]);
                const l2BotMs = getTimeMs(row[COL_MAP.LOOP2_BOTTOM]); const l2TopMs = getTimeMs(row[COL_MAP.LOOP2_TOP]);
                const l3BotMs = getTimeMs(row[COL_MAP.LOOP3_BOTTOM]); const l3TopMs = getTimeMs(row[COL_MAP.LOOP3_TOP]);
                const redCpMs = getTimeMs(row[COL_MAP.RED_CP]);
                processed[COL_MAP.LOOP1_ELAPSED] = (l1BotMs && l1TopMs && l1TopMs > l1BotMs) ? (l1TopMs - l1BotMs) : null;
                processed[COL_MAP.DESC1_ELAPSED] = (l1TopMs && l2BotMs && l2BotMs > l1TopMs) ? (l2BotMs - l1TopMs) : null;
                processed[COL_MAP.LOOP2_ELAPSED] = (l2BotMs && l2TopMs && l2TopMs > l2BotMs) ? (l2TopMs - l2BotMs) : null;
                processed[COL_MAP.DESC2_ELAPSED] = (l2TopMs && l3BotMs && l3BotMs > l2TopMs) ? (l3BotMs - l2TopMs) : null;
                processed[COL_MAP.LOOP3_ELAPSED] = (l3BotMs && l3TopMs && l3TopMs > l3BotMs) ? (l3TopMs - l3BotMs) : null;
                processed[COL_MAP.DESC3_ELAPSED] = (l3TopMs && redCpMs && redCpMs > l3TopMs) ? (redCpMs - l3TopMs) : null;
                // console.log(`Bib ${bib} (50k JS Processed): L1_E_ms=${processed[COL_50K.LOOP1_ELAPSED]}, Total_E_ms=${processed[COL_50K.FINISH_ELAPSED]}`);
                return processed;
            });
        }
        // ****** END UPDATED processData ******

        function identifyDualRunners() { /* ... same as before ... */ dualRunnerNames.clear(); if (all50kRunnerNames.size > 0 && allAscentRunnerNames.size > 0) { all50kRunnerNames.forEach(name => { if (allAscentRunnerNames.has(name)) { dualRunnerNames.add(name); } }); } console.log(`50k Runner Names Set Count: ${all50kRunnerNames.size}`); console.log(`Ascent Runner Names Set Count: ${allAscentRunnerNames.size}`); console.log(`Identified ${dualRunnerNames.size} dual runners (by name):`, dualRunnerNames); }
        function processBigCatData() {
            console.log("Processing Big Cat data..."); calculatedBigCatData = [];
            dualRunnerNames.forEach(name => {
                const ascentResult = calculatedAscentData.find(row => normalizeName(row[COL_ASCENT.NAME]) === name);
                const fiftyKResult = calculated50kData.find(row => normalizeName(row[COL_50K.NAME]) === name);
                if (ascentResult && fiftyKResult) {
                    const ascentTimeMs = ascentResult[COL_ASCENT.FINISH_ELAPSED]; const fiftyKTimeMs = fiftyKResult[COL_50K.FINISH_ELAPSED];
                    let cumulativeMs = null; let status = "In Progress";
                    if (ascentTimeMs && fiftyKTimeMs) { cumulativeMs = ascentTimeMs + fiftyKTimeMs; status = "FINISHED"; }
                    else if ((ascentResult[COL_ASCENT.STATUS] === 'DNF' || ascentResult[COL_ASCENT.STATUS] === 'DNS') || (fiftyKResult[COL_50K.STATUS] === 'DNF' || fiftyKResult[COL_50K.STATUS] === 'DNS')) { status = "DNF/DNS"; }
                    calculatedBigCatData.push({ name: ascentResult[COL_ASCENT.NAME], ascent_elapsed: ascentTimeMs, fiftyk_elapsed: fiftyKTimeMs, cumulative_elapsed: cumulativeMs, status: status });
                } else { console.warn(`Could not find matching results for dual runner: ${name}`); }
            }); console.log(`Processed ${calculatedBigCatData.length} Big Cat runners.`);
        }
        function filterAndSortData() { const sourceData = (activeTab === '50k') ? calculated50kData : (activeTab === 'Ascent' ? calculatedAscentData : calculatedBigCatData); const cols = (activeTab === '50k') ? COL_50K : (activeTab === 'Ascent' ? COL_ASCENT : null); let filteredData = sourceData; if (currentFilter) { const lowerCaseFilter = currentFilter.toLowerCase(); filteredData = sourceData.filter(row => { const bib = String(activeTab !== 'BigCat' ? row[cols.BIB] : '').toLowerCase(); const name = String(row.name || (activeTab !== 'BigCat' ? row[cols.NAME] : '') || '').toLowerCase(); return bib.includes(lowerCaseFilter) || name.includes(lowerCaseFilter); }); } const { column, direction } = currentSort; const sortMultiplier = direction === 'asc' ? 1 : -1; filteredData.sort((a, b) => { let valA, valB; if (activeTab === 'BigCat') { valA = a[column]; valB = b[column]; } else { const sortColIndex = cols[column.toUpperCase()]; if (sortColIndex === undefined) { currentSort.column = 'bib'; return filterAndSortData(); } valA = a[sortColIndex]; valB = b[sortColIndex]; } if (column === 'bib') { valA = parseInt(valA || '0', 10); valB = parseInt(valB || '0', 10); } else if (column.includes('_cp') || column.includes('_scan')) { valA = getTimeMs(valA) ?? (direction === 'asc' ? Infinity : -Infinity); valB = getTimeMs(valB) ?? (direction === 'asc' ? Infinity : -Infinity); } else if (column.includes('_elapsed')) { valA = valA ?? (direction === 'asc' ? Infinity : -Infinity); valB = valB ?? (direction === 'asc' ? Infinity : -Infinity); } else { valA = String(valA || '').toLowerCase(); valB = String(valB || '').toLowerCase(); } if (valA < valB) return -1 * sortMultiplier; if (valA > valB) return 1 * sortMultiplier; return 0; }); return filteredData; }

        // --- UI Update Functions ---
        // (updateTable remains the same - uses formatMillisecondsToDuration for all calculated times)
        function updateTable() {
            const displayData = filterAndSortData();
            const is50k = activeTab === '50k'; const isAscent = activeTab === 'Ascent'; const isBigCat = activeTab === 'BigCat';
            const tableBody = is50k ? resultsBody50k : (isAscent ? resultsBodyAscent : resultsBodyBigCat);
            const rowCountEl = is50k ? rowCount50kElement : (isAscent ? rowCountAscentElement : rowCountBigCatElement);
            const cols = is50k ? COL_50K : (isAscent ? COL_ASCENT : null);
            const totalDataLength = is50k ? calculated50kData.length : (isAscent ? calculatedAscentData.length : calculatedBigCatData.length);

            tableBody.innerHTML = '';
            if (!displayData || displayData.length === 0) { const colspan = is50k ? 22 : (isAscent ? 5 : 5); tableBody.innerHTML = `<tr><td colspan="${colspan}" class="text-center text-gray-500 py-4">${currentFilter ? 'No matching runners found.' : 'No results data available yet.'}</td></tr>`; rowCountEl.textContent = `Showing 0 runners`; return; }

            displayData.forEach(row => {
                const tr = document.createElement('tr');
                let name, normalizedName, isDual, nameHtml;
                if (is50k || isAscent) { name = row[cols.NAME] || ''; normalizedName = normalizeName(name); isDual = dualRunnerNames.has(normalizedName); nameHtml = `${name}${isDual ? ' <span title="Big Cat Challenge (Ascent + 50k)">üêÖ</span>' : ''}`; }
                else { name = row.name || ''; nameHtml = `${name} <span title="Big Cat Challenge (Ascent + 50k)">üêÖ</span>`; }

                if (is50k) {
                    tr.innerHTML = `
                        <td>${row[cols.BIB] || ''}</td><td>${nameHtml}</td><td><span class="${getStatusClass(row[cols.STATUS] || 'Active')}">${row[cols.STATUS] || 'Active'}</span></td>
                        <td>${formatTime(row[cols.GREEN_CP])}</td><td>${createLoopSpan(row[cols.LOOP1_COLOR])}</td><td>${formatTime(row[cols.LOOP1_BOTTOM])}</td>
                        <td>${formatTime(row[cols.LOOP1_TOP])}</td><td>${formatMillisecondsToDuration(row[cols.LOOP1_ELAPSED])}</td><td>${formatMillisecondsToDuration(row[cols.DESC1_ELAPSED])}</td>
                        <td>${createLoopSpan(row[cols.LOOP2_COLOR])}</td><td>${formatTime(row[cols.LOOP2_BOTTOM])}</td><td>${formatTime(row[cols.LOOP2_TOP])}</td>
                        <td>${formatMillisecondsToDuration(row[cols.LOOP2_ELAPSED])}</td><td>${formatMillisecondsToDuration(row[cols.DESC2_ELAPSED])}</td>
                        <td>${createLoopSpan(row[cols.LOOP3_COLOR])}</td><td>${formatTime(row[cols.LOOP3_BOTTOM])}</td><td>${formatTime(row[cols.LOOP3_TOP])}</td>
                        <td>${formatMillisecondsToDuration(row[cols.LOOP3_ELAPSED])}</td><td>${formatMillisecondsToDuration(row[cols.DESC3_ELAPSED])}</td>
                        <td>${formatTime(row[cols.RED_CP])}</td><td>${formatTime(row[cols.FINISH_SCAN])}</td><td>${formatMillisecondsToDuration(row[cols.FINISH_ELAPSED])}</td>
                    `;
                } else if (isAscent) {
                     tr.innerHTML = `
                        <td>${row[cols.BIB] || ''}</td><td>${nameHtml}</td><td><span class="${getStatusClass(row[cols.STATUS] || 'Active')}">${row[cols.STATUS] || 'Active'}</span></td>
                        <td>${formatTime(row[cols.FINISH_SCAN])}</td><td>${formatMillisecondsToDuration(row[cols.FINISH_ELAPSED])}</td>
                    `;
                } else { // Big Cat
                     tr.innerHTML = `
                        <td>${nameHtml}</td><td>${formatMillisecondsToDuration(row.ascent_elapsed)}</td><td>${formatMillisecondsToDuration(row.fiftyk_elapsed)}</td>
                        <td>${formatMillisecondsToDuration(row.cumulative_elapsed)}</td><td><span class="${getStatusClass(row.status)}">${row.status}</span></td>
                    `;
                }
                tableBody.appendChild(tr);
            });
             rowCountEl.textContent = `Showing ${displayData.length} of ${totalDataLength} runners`;
        }
        function updateSortIcons() { const headers = (activeTab === '50k') ? tableHeaders50k : (activeTab === 'Ascent' ? tableHeadersAscent : tableHeadersBigCat); headers.forEach(th => { const sortKey = th.getAttribute('data-sort'); th.classList.remove('sort-asc', 'sort-desc'); const iconSpan = th.querySelector('.sort-icon'); if (iconSpan) iconSpan.textContent = ''; if (sortKey === currentSort.column) { th.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc'); if (iconSpan) iconSpan.textContent = currentSort.direction === 'asc' ? ' ‚ñ≤' : ' ‚ñº'; } }); }

        // --- Event Handlers ---
        function handleSortClick(event) { const clickedHeader = event.currentTarget; const sortKey = clickedHeader.getAttribute('data-sort'); if (!sortKey) return; if (currentSort.column === sortKey) { currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc'; } else { currentSort.column = sortKey; currentSort.direction = 'asc'; } console.log(`Sorting by ${currentSort.column}, direction ${currentSort.direction}`); updateTable(); updateSortIcons(); }
        function handleFilterInput() { currentFilter = searchInput.value.trim(); console.log(`Filtering by: ${currentFilter}`); updateTable(); }
        function handleTabClick(event) { const clickedTab = event.currentTarget; const targetId = clickedTab.getAttribute('data-target'); tabButton50k.classList.toggle('active', targetId === 'results50k'); tabButtonAscent.classList.toggle('active', targetId === 'resultsAscent'); tabButtonBigCat.classList.toggle('active', targetId === 'resultsBigCat'); results50kDiv.classList.toggle('hidden', targetId !== 'results50k'); resultsAscentDiv.classList.toggle('hidden', targetId !== 'resultsAscent'); resultsBigCatDiv.classList.toggle('hidden', targetId !== 'resultsBigCat'); const newActiveTab = targetId.replace('results', ''); if (newActiveTab !== activeTab) { activeTab = newActiveTab; currentSort = (activeTab === 'BigCat') ? { column: 'cumulative_elapsed', direction: 'asc' } : { column: 'bib', direction: 'asc' }; console.log(`Switched to tab: ${activeTab}, reset sort to ${currentSort.column}`); } updateTable(); updateSortIcons(); }

        // --- Data Fetching ---
        // (fetchAllData remains the same - calls processData and processBigCatData)
        async function fetchAllData() { if (isFetching) { console.log("Fetch already in progress."); return; } isFetching = true; console.log("Fetching all data..."); if (loadingSpinner) loadingSpinner.classList.remove('hidden'); errorMessage.classList.add('hidden'); if (!RESULTS_50K_CSV_URL || RESULTS_50K_CSV_URL.includes('YOUR_PUBLISHED') || !RESULTS_ASCENT_CSV_URL || RESULTS_ASCENT_CSV_URL.includes('YOUR_PUBLISHED') || !APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes('PASTE_APPS_SCRIPT')) { console.error("One or more URLs are not configured."); errorMessage.textContent = "Error: Required URLs not configured."; errorDetails.textContent = ""; errorMessage.classList.remove('hidden'); loadingMessage.classList.add('hidden'); resultsTableContainer50k.classList.add('hidden'); resultsTableContainerAscent.classList.add('hidden'); resultsTableContainerBigCat.classList.add('hidden'); isFetching = false; if (loadingSpinner) loadingSpinner.classList.add('hidden'); return; } try { const [res50kCSV, resAscentCSV, runners50kRes, runnersAscentRes] = await Promise.allSettled([ fetch(`${RESULTS_50K_CSV_URL}&t=${Date.now()}`), fetch(`${RESULTS_ASCENT_CSV_URL}&t=${Date.now()}`), fetch(`${APPS_SCRIPT_URL}?action=getRunners&race=50k&t=${Date.now()}`), fetch(`${APPS_SCRIPT_URL}?action=getRunners&race=Ascent&t=${Date.now()}`) ]); all50kRunnerList = []; all50kRunnerNames = new Set(); if (runners50kRes.status === 'fulfilled' && runners50kRes.value.ok) { const data = await runners50kRes.value.json(); if (data.status === 'success' && Array.isArray(data.runners)) { all50kRunnerList = data.runners.map(r => ({ bib: String(r.bib).trim(), name: String(r.name).trim(), status: String(r.status || '').trim() })); all50kRunnerNames = new Set(all50kRunnerList.map(r => normalizeName(r.name))); } else { console.error("Invalid 50k runner list data format"); } } else { console.error("Failed to fetch 50k runner list:", runners50kRes.reason || runners50kRes.value?.statusText); } allAscentRunnerList = []; allAscentRunnerNames = new Set(); if (runnersAscentRes.status === 'fulfilled' && runnersAscentRes.value.ok) { const data = await runnersAscentRes.value.json(); if (data.status === 'success' && Array.isArray(data.runners)) { allAscentRunnerList = data.runners.map(r => ({ bib: String(r.bib).trim(), name: String(r.name).trim(), status: String(r.status || '').trim() })); allAscentRunnerNames = new Set(allAscentRunnerList.map(r => normalizeName(r.name))); } else { console.error("Invalid Ascent runner list data format"); } } else { console.error("Failed to fetch Ascent runner list:", runnersAscentRes.reason || runnersAscentRes.value?.statusText); } identifyDualRunners(); if (res50kCSV.status === 'fulfilled' && res50kCSV.value.ok) { const csvData = await res50kCSV.value.text(); all50kDataFromCSV = parseCSV(csvData); calculated50kData = processData(all50kDataFromCSV, '50k'); } else { console.error("Failed to fetch 50k results CSV:", res50kCSV.reason || res50kCSV.value?.statusText); errorMessage.textContent = "Error loading 50k results."; errorMessage.classList.remove('hidden'); } if (resAscentCSV.status === 'fulfilled' && resAscentCSV.value.ok) { const csvData = await resAscentCSV.value.text(); allAscentResultsFromCSV = parseCSV(csvData); calculatedAscentData = processData(allAscentResultsFromCSV, 'Ascent'); } else { console.error("Failed to fetch Ascent results CSV:", resAscentCSV.reason || resAscentCSV.value?.statusText); errorMessage.textContent = "Error loading Ascent results."; errorMessage.classList.remove('hidden'); } processBigCatData(); updateTable(); updateSortIcons(); resultsTableContainer50k.classList.remove('hidden'); resultsTableContainerAscent.classList.remove('hidden'); resultsTableContainerBigCat.classList.remove('hidden'); loadingMessage.classList.add('hidden'); if (res50kCSV.status === 'fulfilled' && resAscentCSV.status === 'fulfilled' && runners50kRes.status === 'fulfilled' && runnersAscentRes.status === 'fulfilled') { errorMessage.classList.add('hidden'); } lastUpdatedElement.textContent = new Date().toLocaleTimeString(); } catch (error) { console.error('Error fetching/processing data:', error); errorMessage.textContent = "Error loading results. Displaying previous data."; errorDetails.textContent = `Details: ${error.message}`; errorMessage.classList.remove('hidden'); if (resultsTableContainer50k.classList.contains('hidden') && resultsTableContainerAscent.classList.contains('hidden')) { loadingMessage.classList.remove('hidden'); } } finally { isFetching = false; if (loadingSpinner) loadingSpinner.classList.add('hidden'); } }

        // --- Initial Setup ---
        searchInput.addEventListener('input', handleFilterInput);
        tableHeaders50k.forEach(th => th.addEventListener('click', handleSortClick));
        tableHeadersAscent.forEach(th => th.addEventListener('click', handleSortClick));
        tableHeadersBigCat.forEach(th => th.addEventListener('click', handleSortClick));
        tabButton50k.addEventListener('click', handleTabClick);
        tabButtonAscent.addEventListener('click', handleTabClick);
        tabButtonBigCat.addEventListener('click', handleTabClick);
        fetchAllData(); // Initial fetch
        if (REFRESH_INTERVAL_MS > 0) { refreshIntervalId = setInterval(fetchAllData, REFRESH_INTERVAL_MS); console.log(`Auto-refresh enabled every ${REFRESH_INTERVAL_MS / 1000} seconds.`); }

    </script>

</body>
</html>
