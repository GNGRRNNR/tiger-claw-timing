<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèÉ</text></svg>">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com;">
<meta name="theme-color" content="#28a745">
<!-- Add these to your <head> section -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Tiger Claw">
<meta name="mobile-web-app-capable" content="yes">
<link rel="apple-touch-icon" href="icons/icon-192x192.png">

<link rel="manifest" href="manifest.json">
<title>Tiger Claw Timing System</title>
<style>
/* Basic styling */
* {
box-sizing: border-box;
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}

#tiger-claw-app {
max-width: 500px;
margin: 0 auto;
padding: 20px;
background-color: #f9f9f9;
border-radius: 10px;
box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.app-header {
text-align: center;
margin-bottom: 20px;
}

.app-header h1 {
color: #1e7e34;
margin-bottom: 5px;
}

.form-group {
margin-bottom: 15px;
}

label {
display: block;
margin-bottom: 5px;
font-weight: bold;
}

select, input, button {
width: 100%;
padding: 10px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 16px;
}

button {
background-color: #28a745;
color: white;
border: none;
cursor: pointer;
font-weight: bold;
margin-top: 10px;
padding: 12px;
}

button:hover {
background-color: #218838;
}

button:disabled {
background-color: #6c757d;
cursor: not-allowed;
}

.error-message {
color: #dc3545;
margin-top: 5px;
font-size: 14px;
}

.success-message {
color: #28a745;
margin-top: 5px;
font-size: 14px;
}

.connection-status {
display: flex;
align-items: center;
justify-content: center;
margin-bottom: 10px;
font-size: 14px;
}

.status-connected {
color: #28a745;
}

.status-disconnected {
color: #dc3545;
}

.status-icon {
margin-right: 5px;
}

.hidden {
display: none !important;
}

.scanner-container {
position: relative;
margin: 10px 0;
/* Make scanner more prominent and higher in the view */
max-width: 350px;
margin-left: auto;
margin-right: auto;
}

/* QR reader container - let it use natural aspect ratio */
#qr-reader {
width: 100% !important;
border: none !important;
box-shadow: none !important;
position: relative;
overflow: hidden;
border-radius: 8px;
background-color: transparent !important;
}

/* Fix for black rectangle */
#qr-reader__dashboard_section_csr {
background: transparent !important;
padding: 0 !important;
display: none !important;
}

#qr-reader__scan_region {
background: transparent !important;
}

#qr-reader video {
max-height: 300px !important;
object-fit: cover !important;
}

/* Make sure only one camera view is visible */
#qr-reader__scan_region video:nth-child(n+2) {
display: none !important;
}

#qr-reader__status_span {
display: none !important;
background-color: #f0fdf4 !important;
color: #166534 !important;
}

/* Targeting overlay - adapt to the actual camera view */
.targeting-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 5;
}

.targeting-overlay::before {
content: '';
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 70%;
height: 70%;
border: 2px dashed #28a745;
border-radius: 8px;
}

.targeting-overlay::after {
content: '';
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 20px;
height: 20px;
border: 2px solid #28a745;
border-radius: 50%;
}

.flash-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(40, 167, 69, 0.7);
z-index: 9999;
display: none;
}

.pending-uploads {
background-color: #fff3cd;
color: #856404;
padding: 10px;
border-radius: 5px;
margin-top: 15px;
font-size: 14px;
}

.loading-spinner {
display: inline-block;
width: 20px;
height: 20px;
border: 3px solid rgba(0, 0, 0, 0.1);
border-radius: 50%;
border-top-color: #28a745;
animation: spin 1s ease-in-out infinite;
margin-right: 10px;
}

@keyframes spin {
to { transform: rotate(360deg); }
}

/* QR Scanner customizations */
#qr-reader__scan_region {
min-height: 300px;
}

/* Hide unnecessary elements */
#qr-reader__dashboard_section_swaplink,
#qr-reader__dashboard_section_csr button,
#qr-reader__camera_selection,
#qr-reader__filescan_input,
#qr-reader__filescan_input + span {
display: none !important;
}

/* Hide the built-in QR scanner border */
#qr-reader video {
border: none !important;
}

/* Hide the built-in QR scanner reticule */
#qr-reader__scan_region_highlight {
display: none !important;
}

/* Recent scans list */
.recent-scans {
margin-top: 20px;
border-top: 1px solid #ddd;
padding-top: 10px;
}

.recent-scans h3 {
margin-top: 0;
font-size: 16px;
}

.scan-item {
padding: 8px;
border-bottom: 1px solid #eee;
display: flex;
justify-content: space-between;
}

.scan-item:last-child {
border-bottom: none;
}

.scan-bib {
font-weight: bold;
}

.scan-time {
color: #666;
font-size: 14px;
}

/* Debug panel */
.debug-panel {
margin-top: 20px;
padding: 10px;
background-color: #f8f9fa;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 12px;
}

.debug-panel h4 {
margin-top: 0;
margin-bottom: 5px;
}

.debug-panel pre {
margin: 0;
white-space: pre-wrap;
word-break: break-all;
}

/* Native camera fallback */
#native-camera-container {
display: flex;
flex-direction: column;
align-items: center;
margin: 20px 0;
}

#native-camera-video {
width: 100%;
max-width: 350px;
border-radius: 8px;
background-color: #000;
object-fit: cover;
}

#native-camera-canvas {
display: none;
}

/* Camera instructions */
.camera-instructions {
text-align: center;
margin: 10px 0;
font-size: 14px;
color: #666;
}

/* Manual entry section - make it more compact when scanner is active */
.scanner-active .manual-entry-section {
margin-top: 10px;
padding-top: 10px;
border-top: 1px solid #ddd;
}

.scanner-active .manual-entry-section h2 {
font-size: 16px;
margin-top: 0;
margin-bottom: 10px;
}

/* Camera loading indicator */
.camera-loading {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
background-color: rgba(0, 0, 0, 0.7);
color: white;
border-radius: 8px;
z-index: 10;
}

.camera-loading .spinner {
width: 40px;
height: 40px;
border: 4px solid rgba(255, 255, 255, 0.3);
border-radius: 50%;
border-top-color: white;
animation: spin 1s ease-in-out infinite;
margin-bottom: 10px;
}

/* Center connection status and refresh button */
.connection-container {
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
margin-bottom: 15px;
}

#refresh-button {
background-color: #28a745;
margin: 5px auto;
display: block;
width: auto;
font-size: 12px;
padding: 5px 10px;
max-width: 200px;
}

/* Checkpoint stats */
.checkpoint-stats {
background-color: #e9f7ef;
border-radius: 5px;
padding: 10px;
margin: 10px 0;
text-align: center;
font-size: 14px;
}

.checkpoint-stats .progress-bar {
height: 10px;
background-color: #e0e0e0;
border-radius: 5px;
margin: 5px 0;
overflow: hidden;
}

.checkpoint-stats .progress-bar-fill {
height: 100%;
background-color: #28a745;
border-radius: 5px;
transition: width 0.5s ease;
}

.checkpoint-stats .stats-numbers {
display: flex;
justify-content: space-between;
font-size: 12px;
color: #666;
}

.checkpoint-stats .refresh-stats {
background-color: transparent;
color: #28a745;
border: 1px solid #28a745;
padding: 5px 10px;
font-size: 12px;
margin-top: 5px;
cursor: pointer;
}

.checkpoint-stats .refresh-stats:hover {
background-color: #f0f9f2;
}

/* DNF indicator */
.dnf-indicator {
background-color: #dc3545;
color: white;
padding: 2px 5px;
border-radius: 3px;
font-size: 10px;
margin-left: 5px;
}

/* Loading error message */
.loading-error {
color: #dc3545;
margin-top: 10px;
text-align: center;
}

.loading-error button {
background-color: #dc3545;
margin-top: 10px;
padding: 8px 15px;
font-size: 14px;
width: auto;
display: inline-block;
}

/* Stats refreshing indicator */
.stats-refreshing {
display: inline-block;
width: 12px;
height: 12px;
border: 2px solid rgba(40, 167, 69, 0.3);
border-radius: 50%;
border-top-color: #28a745;
animation: spin 1s ease-in-out infinite;
margin-left: 5px;
}

/* Offline mode banner */
.offline-banner {
background-color: #dc3545;
color: white;
text-align: center;
padding: 5px;
font-weight: bold;
margin-bottom: 10px;
border-radius: 5px;
}

/* Admin section */
#admin-section {
margin-top: 20px;
padding: 15px;
background-color: #f8f9fa;
border: 1px solid #ddd;
border-radius: 5px;
}

#admin-section h3 {
margin-top: 0;
margin-bottom: 15px;
}

/* Install prompt - Blue banner across the top */
.install-prompt {
background-color: #e6f2ff;
border-bottom: 2px solid #0066cc;
padding: 8px 15px;
margin: 0 0 15px 0;
text-align: center;
width: 100%;
display: flex;
align-items: center;
justify-content: space-between;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
font-size: 14px;
color: #0066cc;
}

.install-btn {
background-color: #0066cc;
color: white;
border: none;
border-radius: 4px;
padding: 5px 10px;
font-size: 12px;
cursor: pointer;
transition: background-color 0.3s;
margin: 0 0 0 10px;
}

.install-btn:hover {
background-color: #0052a3;
}

.persistent-install-btn {
background-color: #0066cc;
color: white;
border: none;
border-radius: 4px;
padding: 5px 10px;
font-size: 12px;
position: absolute;
top: 10px;
right: 10px;
z-index: 1000;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
display: flex;
align-items: center;
justify-content: center;
}

.persistent-install-btn::before {
content: "üì±";
margin-right: 5px;
font-size: 14px;
}

/* Download Section */
.download-section {
background-color: #f8f9fa;
border: 1px solid #ddd;
border-radius: 8px;
padding: 15px;
margin: 20px 0;
text-align: center;
}

.download-section h3 {
color: #1e7e34;
margin-top: 0;
margin-bottom: 10px;
}

.download-section p {
margin-bottom: 15px;
font-size: 14px;
}

.platform-buttons {
display: flex;
flex-wrap: wrap;
justify-content: center;
gap: 10px;
}

.platform-button, .icon-button {
  background-color: #0066cc !important; /* Blue color with !important to override */
  color: white;
  border: none;
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 100px;
}

.platform-button:hover, .icon-button:hover {
  background-color: #0052a3 !important; /* Darker blue on hover */
}

.platform-icon {
margin-right: 8px;
font-size: 18px;
}

/* iOS-specific install instructions */
.ios-instructions {
text-align: left;
margin: 15px auto;
max-width: 280px;
font-size: 14px;
}

.ios-instructions ol {
padding-left: 20px;
}

.ios-instructions li {
margin-bottom: 8px;
}

/* Make the install icons container appear at the top */
.install-icons {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin: 0 0 10px 0;
  padding: 5px;
  background-color: #e6f2ff;
  border-bottom: 1px solid #0066cc;
  width: 100%;
}

/* Make the icon buttons smaller */
.icon-button {
  padding: 4px 8px;
  font-size: 12px;
}

.icon-button:hover {
background-color: #218838;
transform: translateY(-2px);
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.platform-icon {
margin-right: 8px;
font-size: 16px;
}
</style>
</head>
<body>
<div id="flash-overlay" class="flash-overlay"></div>
<div id="tiger-claw-app">
  <!-- Offline Banner -->
  <div id="offline-banner" class="offline-banner hidden">
    You are currently offline. Scans will be saved and uploaded when connection is restored.
  </div>

  <!-- Install Prompt -->
  <div id="install-prompt" class="install-prompt hidden">
    <span>üì± Add this app to your home screen for better offline access</span>
    <button id="install-btn" class="install-btn">Install</button>
  </div>

  <!-- Loading Screen -->
  <div id="loading-screen">
    <div class="app-header">
      <h1>TIGER CLAW TIMING SYSTEM</h1>
      <p>Loading runner data...</p>
      <div class="loading-spinner"></div>
      <div id="loading-error" class="loading-error hidden">
        <p>Error loading runner data. Please try again.</p>
        <button id="retry-loading">Retry</button>
      </div>
    </div>
  </div>

  <!-- Login Screen -->
  <div id="login-screen" class="hidden">
    <div class="app-header">
      <h1>TIGER CLAW TIMING SYSTEM</h1>
    </div>

    

<form id="login-form">
    <div class="form-group">
  <label for="location-select">Select Location</label>
  <select id="location-select">
    <option value="">Select location</option>
    <optgroup label="ASCENT">
      <option value="ASCENT|FINISHLINE">FINISHLINE</option>
    </optgroup>
    <optgroup label="50K">
      <option value="50K|GREEN CHECKPOINT">GREEN CHECKPOINT</option>
      <option value="50K|PINK LOOP TOP">PINK LOOP TOP</option>
      <option value="50K|PINK LOOP BOTTOM">PINK LOOP BOTTOM</option>
      <option value="50K|YELLOW LOOP TOP">YELLOW LOOP TOP</option>
      <option value="50K|YELLOW LOOP BOTTOM">YELLOW LOOP BOTTOM</option>
      <option value="50K|WHITE LOOP TOP">WHITE LOOP TOP</option>
      <option value="50K|WHITE LOOP BOTTOM">WHITE LOOP BOTTOM</option>
      <option value="50K|RED CHECKPOINT">RED CHECKPOINT</option>
      <option value="50K|FINISHLINE">FINISHLINE</option>
    </optgroup>
  </select>
</div>

    

      <div class="form-group">
        <label for="password-input">Password</label>
        <input type="password" id="password-input" placeholder="Enter password" autocomplete="current-password">
        <div id="login-error" class="error-message hidden"></div>
      </div>

      <!-- Hidden username field for accessibility -->
<div class="form-group" style="display:none;">
  <label for="username-input">Username</label>
  <input type="text" id="username-input" name="username" autocomplete="username">
</div>

    <!-- Download Section (add this to the login screen) -->
    <div class="download-section">
      <h3>üì± Download Tiger Claw Timing App</h3>
      <p>Install this app on your device for offline access and faster scanning</p>

      <div class="platform-buttons">
        <button id="android-install-btn" class="platform-button">
          <span class="platform-icon">ü§ñ</span> Android
        </button>
        <button id="ios-install-btn" class="platform-button">
          <span class="platform-icon">üçé</span> iPhone/iPad
        </button>
      </div>

      <div id="ios-install-instructions" class="ios-instructions hidden">
        <ol>
          <li>Tap the share button <span style="font-size: 1.2em;">‚éô</span> at the bottom of your screen</li>
          <li>Scroll down and tap "Add to Home Screen"</li>
          <li>Tap "Add" in the top right corner</li>
        </ol>
      </div>
    </div>

    <!-- Debug panel toggle -->
    <div style="margin-top: 20px; text-align: center;">
      <button id="toggle-debug" style="background-color: #6c757d; width: auto; font-size: 12px; padding: 5px 10px;">Show Debug Panel</button>
    </div>
  </div>

  <!-- Scanner Screen -->
  <div id="scanner-screen" class="hidden">
  <div class="install-icons">
    <button id="scanner-android-install" class="icon-button" title="Install on Android">
      <span class="platform-icon">ü§ñ</span> Install App
    </button>
    <button id="scanner-ios-install" class="icon-button" title="Install on iOS">
      <span class="platform-icon">üçé</span> Install App
    </button>
  </div>
  
  <div class="app-header">
    <!-- 1. Tiger Claw Timing and checkpoint indicator at the top -->
    <h1>TIGER CLAW TIMING</h1>
    <div id="event-display" style="font-weight: bold; font-size: 18px; margin: 5px 0;"></div>
    <div id="checkpoint-display" style="font-weight: bold; font-size: 18px; margin: 10px 0;"></div>

    <!-- 2. Connection status and refresh button side by side -->
    <div class="connection-container" style="display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 10px;">
      <div id="connection-status" class="connection-status" style="margin-bottom: 0;">
        <span id="status-icon" class="status-icon">‚óè</span>
        <span id="status-text">CHECKING CONNECTION...</span>
      </div>
      <button id="refresh-button" style="margin: 0; width: auto; padding: 5px 10px;">Refresh Connection</button>
    </div>
  </div>

  <!-- 3. Start scanning functionality -->
  <button id="scan-button" class="scan-button">üì∑ START SCANNING üì∑</button>

  <!-- HTML5QrCode scanner container -->
  <div id="scanner-container" class="scanner-container hidden">
    <div id="qr-reader"></div>
    <div class="targeting-overlay"></div>
    <div id="flash-overlay" class="flash-overlay"></div>
    <div id="camera-loading" class="camera-loading">
      <div class="spinner"></div>
      <div>Starting camera...</div>
    </div>
    <div class="camera-instructions">Align QR code within the target</div>
  </div>

  <!-- Native camera fallback -->
  <div id="native-camera-container" class="hidden">
    <video id="native-camera-video" autoplay playsinline></video>
    <canvas id="native-camera-canvas"></canvas>
    <div class="camera-instructions">Align QR code within the target</div>
  </div>

  <div id="message" class="success-message hidden"></div>

  <!-- 4. Stats and refresh stats indicator -->
  <div id="checkpoint-stats" class="checkpoint-stats">
    <div id="stats-text">Loading checkpoint stats...</div>
    <div class="progress-bar">
      <div id="progress-bar-fill" class="progress-bar-fill" style="width: 0%"></div>
    </div>
    <div class="stats-numbers">
      <span id="scanned-count">0 scanned</span>
      <span id="remaining-count">0 remaining</span>
    </div>
    <button id="refresh-stats" class="refresh-stats">Refresh Stats</button>
    <span id="stats-refreshing" class="stats-refreshing hidden"></span>
  </div>

  <div id="scanner-ios-instructions" class="ios-instructions hidden">
    <ol>
      <li>Tap the share button <span style="font-size: 1.2em;">‚éô</span> at the bottom of your screen</li>
      <li>Scroll down and tap "Add to Home Screen"</li>
      <li>Tap "Add" in the top right corner</li>
    </ol>
  </div>

  <div class="form-group manual-entry-section" style="margin-top: 20px;">
    <h2>Manual Entry</h2>
    <div class="form-group">
      <label for="bib-input">Bib Number (required)</label>
      <input type="tel" id="bib-input" inputmode="numeric" pattern="[0-9]*" placeholder="Enter bib number">
    </div>

    <button id="manual-submit-button">SUBMIT</button>
  </div>

  <div id="pending-uploads" class="pending-uploads hidden"></div>

  <div id="recent-scans" class="recent-scans">
    <h3>Recent Scans</h3>
    <div id="scans-list"></div>
  </div>

  <button id="logout-button" style="background-color: #6c757d; margin-top: 20px;">Logout</button>

  <!-- Debug panel (hidden by default) -->
  <div id="debug-panel" class="debug-panel hidden">
    <h4>Debug Info</h4>
    <pre id="debug-info"></pre>
    <button id="force-upload" style="background-color: #6c757d; margin-top: 10px; font-size: 12px;">Force Upload Pending Scans</button>
    <button id="clear-data" style="background-color: #dc3545; margin-top: 10px; font-size: 12px;">Clear All Data</button>
    <button id="refresh-runners" style="background-color: #007bff; margin-top: 10px; font-size: 12px;">Refresh Runner Data</button>
  </div>
</div>
</div>

<!-- Include the HTML5 QR Code Scanner library directly in the HTML -->
<script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

<script>
// Main application code
// Add this to your JavaScript to ensure all install buttons are blue
document.addEventListener('DOMContentLoaded', function() {
  // Make all platform buttons blue
  const platformButtons = document.querySelectorAll('.platform-button, .icon-button');
  platformButtons.forEach(button => {
    button.style.backgroundColor = '#0066cc';
  });
  
  // Ensure the persistent install button is blue
  if (persistentInstallBtn) {
    persistentInstallBtn.style.backgroundColor = '#0066cc';
  }
});
  
  
// DOM Elements
const loadingScreen = document.getElementById('loading-screen');
const loadingError = document.getElementById('loading-error');
const retryLoadingBtn = document.getElementById('retry-loading');
const loginScreen = document.getElementById('login-screen');
const scannerScreen = document.getElementById('scanner-screen');
const passwordInput = document.getElementById('password-input');
const loginError = document.getElementById('login-error');
const loginForm = document.getElementById('login-form');
const checkpointDisplay = document.getElementById('checkpoint-display');
const scanButton = document.getElementById('scan-button');
const scannerContainer = document.getElementById('scanner-container');
const nativeCameraContainer = document.getElementById('native-camera-container');
const nativeCameraVideo = document.getElementById('native-camera-video');
const nativeCameraCanvas = document.getElementById('native-camera-canvas');
const flashOverlay = document.getElementById('flash-overlay');
const cameraLoading = document.getElementById('camera-loading');
const messageDisplay = document.getElementById('message');
const bibInput = document.getElementById('bib-input');
const manualSubmitButton = document.getElementById('manual-submit-button');
const logoutButton = document.getElementById('logout-button');
const connectionStatus = document.getElementById('connection-status');
const statusIcon = document.getElementById('status-icon');
const statusText = document.getElementById('status-text');
const pendingUploadsContainer = document.getElementById('pending-uploads');
const scansList = document.getElementById('scans-list');
const debugPanel = document.getElementById('debug-panel');
const debugInfo = document.getElementById('debug-info');
const toggleDebugBtn = document.getElementById('toggle-debug');
const forceUploadBtn = document.getElementById('force-upload');
const clearDataBtn = document.getElementById('clear-data');
const refreshButton = document.getElementById('refresh-button');
const refreshRunnersBtn = document.getElementById('refresh-runners');
const offlineBanner = document.getElementById('offline-banner');
const installPrompt = document.getElementById('install-prompt');
const installBtn = document.getElementById('install-btn');
const iosInstructions = document.getElementById('ios-install-instructions');
const locationSelect = document.getElementById('location-select');
const eventDisplay = document.getElementById('event-display');

// Checkpoint stats elements
const checkpointStats = document.getElementById('checkpoint-stats');
const statsText = document.getElementById('stats-text');
const progressBarFill = document.getElementById('progress-bar-fill');
const scannedCount = document.getElementById('scanned-count');
const remainingCount = document.getElementById('remaining-count');
const refreshStatsBtn = document.getElementById('refresh-stats');
const statsRefreshing = document.getElementById('stats-refreshing');

// Application state
let deferredInstallPrompt = null; // Store the install prompt event
let isScanning = false;
let isOnline = navigator.onLine;
let html5QrCode = null;
let checkpoint = '';
let pendingUploads = [];
let runnersData = {}; // Will store all runners data
let recentScans = []; // Store recent scans for display
let lastUploadAttempt = 0; // Track last upload attempt time
let debugMode = false; // Debug mode flag
let useNativeCamera = false; // Whether to use native camera API as fallback
let nativeCameraStream = null; // Store the camera stream
let processedScans = {}; // Track processed scans to prevent duplicates
let scanTimestamps = {}; // Track timestamps of scans to ensure we only keep the most recent
let cameraStartTimeout = null; // Timeout for camera start
let isUploadingPendingScans = false; // Flag to prevent multiple simultaneous uploads
let uploadedScans = {}; // Track which scans have been uploaded to prevent duplicates
let runnerDataRefreshInterval = null; // Interval for refreshing runner data
let checkpointStatsRefreshInterval = null; // Interval for refreshing checkpoint stats
let alreadyScannedRunners = new Set(); // Track which runners have already been scanned at this checkpoint
let isLoadingRunnerData = false; // Flag to prevent multiple simultaneous data loads
let isRefreshingStats = false; // Flag to prevent multiple simultaneous stats refreshes
let lastDnfCheck = 0; // Track when we last checked for DNF updates
let periodicUploadInterval = null; // Interval for periodic upload attempts
let dataLoadTimeoutId = null; // Store the timeout ID for data loading
let dataLoadAttempted = false; // Flag to track if we've attempted to load data
let persistentInstallBtn = null; // Store the persistent install button element
let event = '';


let lastPendingUploadsCount = 0;
let lastPendingUploadsData = [];
let pendingUploadsMonitorActive = false;
  
// Constants
const CORRECT_PASSWORD = "threeloops";
const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbw0myP_7idi4yuiToxjILjuheiiy_QvBQu1htF4HSJ68A5T3w1e-R2ceXwfSTzHFw/exec";
const RUNNER_DATA_REFRESH_INTERVAL = 2 * 60 * 1000; // 2 minutes
const CHECKPOINT_STATS_REFRESH_INTERVAL = 30 * 1000; // 30 seconds
const DNF_CHECK_INTERVAL = 60 * 1000; // 1 minute
const PERIODIC_UPLOAD_INTERVAL = 30 * 1000; // 30 seconds

// Spreadsheet configuration
const RUNNERS_SHEET_ID = "19ysJEfg5dDTUe6q-JXngWbUAziGmrn0jGilGy8SkcYg"; // Your runners spreadsheet ID
const RESULTS_SHEET_ID = "1StRgcagtoZs6x-TRCQMAWiTIqXKq__6_Gvcj8ysUz5c"; // Your results spreadsheet ID

// Event Configuration
const EVENT_CONFIG = {
  "50K": {
    RUNNERS_SHEET_ID: "19ysJEfg5dDTUe6q-JXngWbUAziGmrn0jGilGy8SkcYg",
    RUNNERS_SHEET_NAME: "50k RUNNERS",
    RESULTS_SHEET_ID: "1StRgcagtoZs6x-TRCQMAWiTIqXKq__6_Gvcj8ysUz5c",
    RESULTS_SHEET_NAME: "50k CHECKPOINT SCANS",
    CHECKPOINTS: [
      "GREEN CHECKPOINT",
      "PINK LOOP TOP",
      "PINK LOOP BOTTOM",
      "YELLOW LOOP TOP",
      "YELLOW LOOP BOTTOM",
      "WHITE LOOP TOP",
      "WHITE LOOP BOTTOM",
      "RED CHECKPOINT",
      "FINISHLINE",
    ],
  },
  ASCENT: {
    RUNNERS_SHEET_ID: "19ysJEfg5dDTUe6q-JXngWbUAziGmrn0jGilGy8SkcYg",
    RUNNERS_SHEET_NAME: "ASCENT RUNNERS",
    RESULTS_SHEET_ID: "1StRgcagtoZs6x-TRCQMAWiTIqXKq__6_Gvcj8ysUz5c",
    RESULTS_SHEET_NAME: "ASCENT RESULTS",
    CHECKPOINTS: ["FINISHLINE"],
  },
}


const CACHE_NAME = "my-site-cache-v1"
const urlsToCache = ["/", "/index.html", "/style.css", "/script.js"]

// Update your service worker installation event to handle errors better
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log("Opened cache")
      // Use individual cache.add calls instead of cache.addAll to handle failures better
      return Promise.allSettled(
        urlsToCache.map((url) => cache.add(url).catch((err) => console.log(`Failed to cache ${url}: ${err}`))),
      )
    }),
  )
})


const DATA_LOAD_TIMEOUT = 30000; // 30 seconds timeout for data loading


const checkpointStatsContent = document.getElementById('checkpoint-stats');

  

// Check for URL parameters (for QR code login)
function checkUrlParameters() {
  const urlParams = new URLSearchParams(window.location.search);
  const checkpointParam = urlParams.get('checkpoint');
  const passwordParam = urlParams.get('password');

  if (checkpointParam && passwordParam) {
    logDebug(`Found URL parameters: checkpoint=${checkpointParam}`);
    
    // Auto-fill the login form
    const checkpointOption = Array.from(checkpointSelect.options).find(
      option => option.value === checkpointParam
    );
    
    if (checkpointOption) {
      checkpointSelect.value = checkpointParam;
      passwordInput.value = passwordParam;
      
      // Auto login after a short delay
      setTimeout(() => {
        handleLogin();
      }, 500);
    }
  }
}

// Register service worker for offline support
function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('service-worker.js')
      .then(registration => {
        logDebug('Service Worker registered with scope: ' + registration.scope);
      })
      .catch(error => {
        logDebug('Service Worker registration failed: ' + error);
      });
  }
}

// Function to show appropriate install prompts on both screens
function updateInstallPrompts() {
  if (deferredInstallPrompt && !isIOS()) {
    // Show install prompts on both screens
    if (installPrompt) installPrompt.classList.remove('hidden');
    if (persistentInstallBtn) persistentInstallBtn.classList.remove('hidden');
    // Position the install prompt at the top of the current screen
    positionInstallPrompt();
    logDebug("Install prompts shown on all screens");
  } else if (isIOS()) {
    // Show iOS-specific instructions
    if (iosInstructions) iosInstructions.classList.remove('hidden');
    logDebug("iOS install instructions shown");
  }
}



// Add this function to monitor pending uploads
function monitorPendingUploads() {
  if (!pendingUploadsMonitorActive) return;
  
  if (pendingUploads.length !== lastPendingUploadsCount) {
    logDebug(`Pending uploads changed: ${lastPendingUploadsCount} -> ${pendingUploads.length}`);
    
    if (pendingUploads.length < lastPendingUploadsCount) {
      logDebug('Pending uploads decreased! Current stack trace:');
      console.trace();
      
      // Find which scans were removed
      const removedScans = lastPendingUploadsData.filter(oldScan => {
        return !pendingUploads.some(newScan => 
          newScan.bib === oldScan.bib && 
          newScan.checkpoint === oldScan.checkpoint
        );
      });
      
      logDebug(`Removed scans: ${JSON.stringify(removedScans)}`);
    }
    
    lastPendingUploadsCount = pendingUploads.length;
    lastPendingUploadsData = JSON.parse(JSON.stringify(pendingUploads));
  }
  
  setTimeout(monitorPendingUploads, 1000);
}


  
// Update this function to ensure the install prompt is at the top
function positionInstallPrompt() {
  const installPrompt = document.getElementById('install-prompt');
  if (!installPrompt) return;
  
  // Get the currently visible screen
  let currentScreen;
  if (!document.getElementById('loading-screen').classList.contains('hidden')) {
    currentScreen = document.getElementById('loading-screen');
  } else if (!document.getElementById('login-screen').classList.contains('hidden')) {
    currentScreen = document.getElementById('login-screen');
  } else if (!document.getElementById('scanner-screen').classList.contains('hidden')) {
    currentScreen = document.getElementById('scanner-screen');
  }
  
  if (currentScreen) {
    // Make sure the install prompt is the first child of the current screen
    currentScreen.insertBefore(installPrompt, currentScreen.firstChild);
    
    // Ensure it's styled as a banner
    installPrompt.style.width = '100%';
    installPrompt.style.margin = '0 0 15px 0';
    installPrompt.style.backgroundColor = '#e6f2ff';
    installPrompt.style.borderBottom = '2px solid #0066cc';
  }
}



function uploadScanDirectly(scan) {
  if (!isOnline) {
    logDebug("Cannot upload scan while offline");
    return Promise.reject(new Error("Offline"));
  }

  logDebug(`Attempting direct upload for bib #${scan.bib} (Event: ${scan.event})`);

  // Get the appropriate sheet name based on event type
  const sheetName = scan.event === "ASCENT" ? "ASCENT RESULTS" : "50k CHECKPOINT SCANS";

  const rowData = [
    scan.timestamp, // TIMESTAMP
    scan.bib, // BIB NUMBER
    scan.name, // RUNNER NAME
    scan.checkpoint, // CHECKPOINT
    scan.event, // EVENT
  ];

  const formData = new FormData();
  formData.append("action", "appendRow");
  formData.append("sheetId", RESULTS_SHEET_ID);
  formData.append("sheetName", sheetName);
  formData.append("data", JSON.stringify(rowData));

  return fetch(APPS_SCRIPT_URL, {
    method: "POST",
    mode: "no-cors",
    body: formData,
  })
    .then(() => {
      logDebug(`Direct upload for bib #${scan.bib} sent to ${sheetName}`);
      return true;
    })
    .catch((error) => {
      logDebug(`Direct upload error: ${error.message}`);
      return false;
    });
}



// Add this function to your code
function calculateLocalCheckpointStats() {
  if (!checkpoint || !event) {
    return { scannedCount: 0, totalRunners: 0, scannedPercentage: 0, dnfCount: 0 }
  }

  logDebug(`Calculating local stats for ${event} at ${checkpoint}`)

  // Count active runners and DNFs for this specific event
  let activeRunners = 0
  let dnfCount = 0

  // Count scanned runners at this checkpoint
  const scannedBibs = new Set()

  // Process each runner
  for (const bib in runnersData) {
    if (runnersData.hasOwnProperty(bib)) {
      const runner = runnersData[bib]

      if (runner.dnf) {
        dnfCount++
      } else {
        activeRunners++

        // Check if this runner has been scanned at this checkpoint
        if (alreadyScannedRunners.has(bib)) {
          scannedBibs.add(bib)
        }
      }
    }
  }

  const scannedCount = scannedBibs.size
  const scannedPercentage = activeRunners > 0 ? Math.round((scannedCount / activeRunners) * 100) : 0

  logDebug(
    `Local checkpoint stats: ${scannedCount}/${activeRunners} active runners scanned (${scannedPercentage}%), ${dnfCount} DNF`,
  )

  return {
    scannedCount: scannedCount,
    totalRunners: activeRunners,
    scannedPercentage: scannedPercentage,
    dnfCount: dnfCount,
  }
}



function fetchCheckpointStats(force = false) {
  if (!force && (!isOnline || !checkpoint || !event)) {
    return
  }

  logDebug(`Fetching checkpoint stats for ${event} at ${checkpoint}`)

  // If we're offline, calculate stats locally
  if (!isOnline) {
    const stats = calculateLocalCheckpointStats()
    updateCheckpointStatsUI(stats)
    return
  }

  // Otherwise, fetch from the spreadsheet
  if (typeof fetchCheckpointStatsFromSpreadsheet === "function") {
    fetchCheckpointStatsFromSpreadsheet()
  } else {
    logDebug("fetchCheckpointStatsFromSpreadsheet function is not defined.")
  }
}


  
  

function setupPersistentInstallButton(btnElement) {
  btnElement.className = "persistent-install-btn hidden";
  btnElement.textContent = "Install App";
  
  // Instead of adding to body, we'll add it to the scanner screen header
  const appHeader = document.querySelector('#scanner-screen .app-header');
  if (appHeader) {
    appHeader.style.position = 'relative'; // Make sure position is relative for absolute positioning
    appHeader.appendChild(btnElement);
  } else {
    // Fallback to body if app header not found
    document.body.appendChild(btnElement);
  }

  // Add click handler
  btnElement.addEventListener("click", triggerInstall);

  // Make sure it's visible if we have an install prompt
  if (deferredInstallPrompt && !isIOS()) {
    btnElement.classList.remove("hidden");
  }

  logDebug("Persistent install button set up");
}

// Detect iOS
function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}

// Detect Android
function isAndroid() {
  return /Android/.test(navigator.userAgent);
}

// Show appropriate install instructions based on platform
function showAppropriateInstallInstructions(androidBtn, iosBtn, iosInstructionsElement) {
  if (isIOS()) {
    if (iosBtn) {
      iosBtn.addEventListener("click", () => {
        iosInstructionsElement.classList.toggle("hidden");
      });
    }
  } else {
    // For Android and other platforms, use the install prompt
    if (androidBtn) {
      androidBtn.addEventListener("click", triggerInstall);
    }
  }
}


// Add this function to your JavaScript
function debugSpreadsheet() {
  logDebug("Starting spreadsheet debug...");
  
  // Check if we're online
  if (!isOnline) {
    logDebug("ERROR: Currently offline. Cannot debug spreadsheet connection.");
    showMessage("Cannot debug spreadsheet while offline", true);
    return;
  }
  
  // Log the spreadsheet IDs we're using
  logDebug(`RUNNERS_SHEET_ID: ${RUNNERS_SHEET_ID}`);
  logDebug(`RESULTS_SHEET_ID: ${RESULTS_SHEET_ID}`);
  
  // Try to fetch the results spreadsheet structure
  const cacheBuster = new Date().getTime();
  const spreadsheetUrl = `https://docs.google.com/spreadsheets/d/${RESULTS_SHEET_ID}/gviz/tq?tqx=out:json&sheet=Sheet1&cacheBuster=${cacheBuster}`;
  
  logDebug(`Fetching spreadsheet structure from: ${spreadsheetUrl}`);
  
  fetch(spreadsheetUrl)
    .then(response => {
      logDebug(`Response status: ${response.status} ${response.statusText}`);
      return response.text();
    })
    .then(text => {
      logDebug(`Raw response (first 300 chars): ${text.substring(0, 300)}...`);
      
      // Try to extract and parse the JSON
      try {
        const jsonStart = text.indexOf('{');
        const jsonEnd = text.lastIndexOf('}') + 1;
        if (jsonStart === -1 || jsonEnd === 0) {
          throw new Error('Invalid response format - could not find JSON data');
        }
        const jsonString = text.substring(jsonStart, jsonEnd);
        const data = JSON.parse(jsonString);
        
        // Log the column structure
        if (data && data.table && data.table.cols) {
          const cols = data.table.cols;
          logDebug(`Found ${cols.length} columns:`);
          cols.forEach((col, index) => {
            logDebug(`Column ${index}: ${col.label || 'UNNAMED'} (${col.type || 'unknown type'})`);
          });
          
          // Check for empty column headers
          const emptyHeaders = cols.filter(col => !col.label || col.label.trim() === '').length;
          if (emptyHeaders > 0) {
            logDebug(`WARNING: Found ${emptyHeaders} empty column headers!`);
          }
        } else {
          logDebug("ERROR: Could not find column structure in response");
        }
        
        // Log the row count
        if (data && data.table && data.table.rows) {
          logDebug(`Found ${data.table.rows.length} rows in the spreadsheet`);
        }
        
        // Try to send a test scan
        logDebug("Attempting to send a test scan...");
        const testScan = {
          bib: "TEST",
          name: "Debug Test",
          checkpoint: checkpoint || "DEBUG",
          timestamp: new Date().toISOString(),
          uploaded: false
        };
        
        const uploadData = {
          action: 'recordScans',
          scans: [testScan],
          debug: true
        };
        
        return fetch(APPS_SCRIPT_URL, {
          method: 'POST',
          mode: 'no-cors',
          cache: 'no-cache',
          headers: {
            'Content-Type': 'text/plain;charset=utf-8',
          },
          body: JSON.stringify(uploadData)
        });
      } catch (error) {
        logDebug(`Error parsing spreadsheet data: ${error.message}`);
        throw error;
      }
    })
    .then(() => {
      logDebug("Test scan sent (no response available due to no-cors mode)");
      showMessage("Debug test completed - check debug panel for results");
    })
    .catch(error => {
      logDebug(`Spreadsheet debug error: ${error.message}`);
      showMessage("Error during spreadsheet debug - check debug panel", true);
    });
}

// Add this button to the debug panel in your HTML
// Find the debug panel div and add this button before the closing </div>
document.addEventListener('DOMContentLoaded', function() {
  const debugPanel = document.getElementById('debug-panel');
  if (debugPanel) {
    const debugSpreadsheetBtn = document.createElement('button');
    debugSpreadsheetBtn.id = 'debug-spreadsheet';
    debugSpreadsheetBtn.textContent = 'Debug Spreadsheet';
    debugSpreadsheetBtn.style.backgroundColor = '#17a2b8';
    debugSpreadsheetBtn.style.marginTop = '10px';
    debugSpreadsheetBtn.style.fontSize = '12px';
    debugSpreadsheetBtn.addEventListener('click', debugSpreadsheet);
    
    // Insert after the refresh-runners button
    const refreshRunnersBtn = document.getElementById('refresh-runners');
    if (refreshRunnersBtn && refreshRunnersBtn.parentNode) {
      refreshRunnersBtn.parentNode.insertBefore(debugSpreadsheetBtn, refreshRunnersBtn.nextSibling);
    } else {
      debugPanel.appendChild(debugSpreadsheetBtn);
    }
  }
});


  

// Add this function to clear upload tracking data
function resetUploadTracking() {
  uploadedScans = {};
  localStorage.removeItem('uploadedScans');
  
  // Also reset processed scans to allow rescanning
  processedScans = {};
  localStorage.removeItem('processedScans');
  
  // Reset scan timestamps
  scanTimestamps = {};
  localStorage.removeItem('scanTimestamps');
  
  logDebug('Upload tracking data has been reset');
  showMessage('Upload tracking data has been reset');
}

  

// Modify the triggerInstall function to hide all prompts
function triggerInstall() {
  if (deferredInstallPrompt) {
    // Show the install prompt
    deferredInstallPrompt.prompt();

    // Wait for the user to respond to the prompt
    deferredInstallPrompt.userChoice.then((choiceResult) => {
      if (choiceResult.outcome === "accepted") {
        logDebug("User accepted the install prompt");
        // Hide all install buttons
        if (installPrompt) installPrompt.classList.add("hidden");
        if (persistentInstallBtn) persistentInstallBtn.classList.add("hidden");
      } else {
        logDebug("User dismissed the install prompt");
      }
      deferredInstallPrompt = null;
    });
  } else {
    showMessage("App installation not available or already installed", true);
  }
}

// Enhanced beforeinstallprompt event handler
window.addEventListener("beforeinstallprompt", (e) => {
  // Prevent Chrome 67 and earlier from automatically showing the prompt
  e.preventDefault();

  // Stash the event so it can be triggered later
  deferredInstallPrompt = e;

  // Update all install prompts
  updateInstallPrompts();

  logDebug("Install prompt detected and saved");
});

// Check if app is already installed
window.addEventListener("appinstalled", (evt) => {
  logDebug("App was installed");
  // Hide install buttons
  if (installPrompt) installPrompt.classList.add("hidden");
  if (persistentInstallBtn) persistentInstallBtn.classList.add("hidden");
});

// Install button click handler
installBtn.addEventListener('click', () => {
  if (deferredInstallPrompt) {
    // Show the install prompt
    deferredInstallPrompt.prompt();
    
    // Wait for the user to respond to the prompt
    deferredInstallPrompt.userChoice.then((choiceResult) => {
      if (choiceResult.outcome === 'accepted') {
        logDebug('User accepted the install prompt');
        installPrompt.classList.add('hidden');
      } else {
        logDebug('User dismissed the install prompt');
      }
      deferredInstallPrompt = null;
    });
  }
});

// Retry loading button
retryLoadingBtn.addEventListener('click', function() {
  loadingError.classList.add('hidden');
  fetchRunnerData(true);
});

// Handle login form submission
loginForm.addEventListener('submit', function(event) {
  event.preventDefault();
  handleLogin();
});


  

function handleLogin() {
  const selectedLocation = locationSelect.value;
  const password = passwordInput.value;

  if (!selectedLocation) {
    loginError.textContent = 'Please select a location';
    loginError.classList.remove('hidden');
    return;
  }

  const [selectedEvent, selectedCheckpoint] = selectedLocation.split('|');
  if (password !== CORRECT_PASSWORD) {
    loginError.textContent = 'Incorrect password';
    loginError.classList.remove('hidden');
    return;
  }

  // Save event/checkpoint
  event = selectedEvent;
  checkpoint = selectedCheckpoint;
  localStorage.setItem('tigerClawEvent', event);
  localStorage.setItem('tigerClawCheckpoint', checkpoint);

  // Clear session and show UI
  clearSessionData();
  showScannerScreen();

  loadRunnersDataWithPriority().then(() => {
    fetchCheckpointStats(true);           // ‚úÖ NOW waits for runner data to be loaded
    fetchAlreadyScannedRunners();         // ‚úÖ Load scanned runners
    startPeriodicUploadAttempts();        // ‚úÖ Begin periodic uploads
  });
}







// Add this function
function startPeriodicUploadAttempts() {
  if (periodicUploadInterval) {
    clearInterval(periodicUploadInterval);
  }
  periodicUploadInterval = setInterval(() => {
    if (isOnline && pendingUploads.length > 0) {
      uploadPendingScans();
    }
  }, PERIODIC_UPLOAD_INTERVAL);
  logDebug("Started periodic upload attempts");
}

// Add this function
function fetchRunnerDataForStats() {
  return new Promise((resolve, reject) => {
    if (Object.keys(runnersData).length > 0) {
      resolve(runnersData);
      return;
    }
    
    fetchRunnerData(true)
      .then(() => resolve(runnersData))
      .catch(reject);
  });
}




// Add this new function for prioritized runner data loading
function loadRunnersDataWithPriority() {
  return new Promise((resolve, reject) => {
    if (isLoadingRunnerData) {
      logDebug("Already loading runner data, waiting...");
      // Check every 100ms if loading is complete
      const checkInterval = setInterval(() => {
        if (!isLoadingRunnerData) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
      return;
    }
    
    // Set loading flag
    isLoadingRunnerData = true;
    
    logDebug(`Priority loading runner data for ${event}`);
    
    // Add a cache-busting parameter
    const cacheBuster = new Date().getTime();
    
    // Use the API to get runner data for the specific event
    fetch(`${APPS_SCRIPT_URL}?action=getRunnerData&eventType=${encodeURIComponent(event)}&cacheBuster=${cacheBuster}`)
      .then(response => {
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        return response.json();
      })
      .then(data => {
        if (data && data.success && data.data && Array.isArray(data.data)) {
          const runners = data.data;
          const runnerMap = {};
          
          // Process each runner
          runners.forEach(runner => {
            const bib = runner.bibNumber;
            const name = runner.name || "Unknown";
            const status = runner.status || "Active";
            const dnf = status === "DNF" || status === "DNS";
            
            runnerMap[bib] = {
              name: name,
              dnf: dnf,
              event: event
            };
          });
          
          if (Object.keys(runnerMap).length === 0) {
            throw new Error(`No runner data found for event: ${event}`);
          }
          
          // Update the last DNF check timestamp
          lastDnfCheck = Date.now();
          
          runnersData = runnerMap;
          localStorage.setItem(`runnersData_${event}`, JSON.stringify(runnersData));
          logDebug(`Loaded ${Object.keys(runnersData).length} runners for event: ${event}`);
          
          // Update checkpoint stats immediately
          updateCheckpointStatsUI(calculateLocalCheckpointStats());
          
          resolve();
        } else {
          throw new Error("Invalid runner data format or empty response");
        }
      })
      .catch(error => {
        logDebug("Error fetching runner data: " + error);
        
        // Try to use cached data
        try {
          const storedData = localStorage.getItem(`runnersData_${event}`);
          if (storedData) {
            const parsedData = JSON.parse(storedData);
            if (parsedData && Object.keys(parsedData).length > 0) {
              runnersData = parsedData;
              logDebug(`Using ${Object.keys(runnersData).length} runners from localStorage`);
              resolve();
              return;
            }
          }
        } catch (e) {
          logDebug("Error loading runners data from localStorage: " + e);
        }
        
        reject(error);
      })
      .finally(() => {
        isLoadingRunnerData = false;
      });
  });
}
  

// Update your showScannerScreen function to properly handle fetchCheckpointStats
// Update the handleLogin function to load stats immediately
function handleLogin() {
  const selectedLocation = locationSelect.value;
  const password = passwordInput.value;

  if (!selectedLocation) {
    loginError.textContent = 'Please select a location';
    loginError.classList.remove('hidden');
    return;
  }

  const [selectedEvent, selectedCheckpoint] = selectedLocation.split('|');

  if (!selectedEvent) {
    loginError.textContent = 'Please select an event';
    loginError.classList.remove('hidden');
    return;
  }

  if (password !== CORRECT_PASSWORD) {
    loginError.textContent = 'Incorrect password';
    loginError.classList.remove('hidden');
    return;
  }

  // Clear old session data
  clearSessionData();

  // Save event and checkpoint
  event = selectedEvent;
  checkpoint = selectedCheckpoint;
  localStorage.setItem('tigerClawEvent', event);
  localStorage.setItem('tigerClawCheckpoint', checkpoint);

  // Show scanner screen immediately
  showScannerScreen();

  // Load runner data with high priority
  loadRunnersDataWithPriority()
    .then(() => {
      // After runner data is loaded, fetch checkpoint stats
      fetchCheckpointStats(true);
      // Then fetch already scanned runners
      fetchAlreadyScannedRunners();
      // Start periodic upload attempts
      startPeriodicUploadAttempts();
    })
    .catch(error => {
      logDebug(`Error in login sequence: ${error}`);
      // Still proceed with what we have
      fetchCheckpointStats(true);
      fetchAlreadyScannedRunners();
      startPeriodicUploadAttempts();
    });
}

// Add this new function for prioritized runner data loading
function loadRunnersDataWithPriority() {
  return new Promise((resolve, reject) => {
    if (isLoadingRunnerData) {
      logDebug("Already loading runner data, waiting...");
      // Check every 100ms if loading is complete
      const checkInterval = setInterval(() => {
        if (!isLoadingRunnerData) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
      return;
    }
    
    // Set loading flag
    isLoadingRunnerData = true;
    
    logDebug(`Priority loading runner data for ${event}`);
    
    // Add a cache-busting parameter
    const cacheBuster = new Date().getTime();
    
    // Use the API to get runner data for the specific event
    fetch(`${APPS_SCRIPT_URL}?action=getRunnerData&eventType=${encodeURIComponent(event)}&cacheBuster=${cacheBuster}`)
      .then(response => {
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        return response.json();
      })
      .then(data => {
        if (data && data.success && data.data && Array.isArray(data.data)) {
          const runners = data.data;
          const runnerMap = {};
          
          // Process each runner
          runners.forEach(runner => {
            const bib = runner.bibNumber;
            const name = runner.name || "Unknown";
            const status = runner.status || "Active";
            const dnf = status === "DNF" || status === "DNS";
            
            runnerMap[bib] = {
              name: name,
              dnf: dnf,
              event: event
            };
          });
          
          if (Object.keys(runnerMap).length === 0) {
            throw new Error(`No runner data found for event: ${event}`);
          }
          
          // Update the last DNF check timestamp
          lastDnfCheck = Date.now();
          
          runnersData = runnerMap;
          localStorage.setItem(`runnersData_${event}`, JSON.stringify(runnersData));
          logDebug(`Loaded ${Object.keys(runnersData).length} runners for event: ${event}`);
          
          // Update checkpoint stats immediately
          updateCheckpointStatsUI(calculateLocalCheckpointStats());
          
          resolve();
        } else {
          throw new Error("Invalid runner data format or empty response");
        }
      })
      .catch(error => {
        logDebug("Error fetching runner data: " + error);
        
        // Try to use cached data
        try {
          const storedData = localStorage.getItem(`runnersData_${event}`);
          if (storedData) {
            const parsedData = JSON.parse(storedData);
            if (parsedData && Object.keys(parsedData).length > 0) {
              runnersData = parsedData;
              logDebug(`Using ${Object.keys(runnersData).length} runners from localStorage`);
              resolve();
              return;
            }
          }
        } catch (e) {
          logDebug("Error loading runners data from localStorage: " + e);
        }
        
        reject(error);
      })
      .finally(() => {
        isLoadingRunnerData = false;
      });
  });
}

  

// Start periodic upload attempts
function loadPendingScans() {
  try {
    const savedPendingUploads = localStorage.getItem('pendingUploads');
    if (savedPendingUploads) {
      const parsed = JSON.parse(savedPendingUploads);
      if (Array.isArray(parsed)) {
        pendingUploads = parsed;
        logDebug(`Loaded ${pendingUploads.length} pending scans from localStorage`);
      } else {
        logDebug('Invalid pending uploads format in localStorage');
        pendingUploads = [];
      }
    } else {
      logDebug('No pending uploads found in localStorage');
      pendingUploads = [];
    }
  } catch (error) {
    logDebug(`Error loading pending scans: ${error}`);
    pendingUploads = [];
  }
}

// Clear session data when logging in
function clearSessionData() {
  // Clear recent scans
  recentScans = [];
  localStorage.removeItem('recentScans');

  // Clear processed scans tracking
  processedScans = {};
  localStorage.removeItem('processedScans');

  // Clear scan timestamps
  scanTimestamps = {};
  localStorage.removeItem('scanTimestamps');

  // Clear already scanned runners
  alreadyScannedRunners = new Set();

  // Update UI
  updateRecentScansUI();

  logDebug('Session data cleared for new login');
}

// Fix for the fetchAlreadyScannedRunners function
function fetchAlreadyScannedRunners() {
  if (!checkpoint || !event || !isOnline) {
    return Promise.resolve()
  }

  logDebug(`Fetching already scanned runners for ${event} at ${checkpoint}`)

  return fetch(
    APPS_SCRIPT_URL +
      "?action=getScanned&eventType=" +
      encodeURIComponent(event) +
      "&checkpoint=" +
      encodeURIComponent(checkpoint),
  )
    .then((response) => {
      if (!response.ok) {
        throw new Error("Network response was not ok")
      }
      return response.json()
    })
    .then((data) => {
      if (data && data.scanned) {
        alreadyScannedRunners = new Set(data.scanned)
        logDebug(`Already scanned runners loaded: ${data.scanned.length} runners for ${event} at ${checkpoint}`)
      } else {
        throw new Error("Invalid data format received for already scanned runners")
      }
    })
    .catch((error) => {
      console.error("Error fetching already scanned runners:", error)
      showMessage("Failed to load already scanned runners. Check your connection and try again.", true)
    })
}

  

function fetchCheckpointStatsFromSpreadsheet() {
  if (!checkpoint || !isOnline) {
    const stats = calculateLocalCheckpointStats();
    updateCheckpointStatsUI(stats);
    if (statsRefreshing) {
      statsRefreshing.classList.add("hidden");
    }
    isRefreshingStats = false;
    return;
  }

  logDebug(`Fetching checkpoint stats from spreadsheet for: ${checkpoint} (Event: ${event})`);
  isRefreshingStats = true;
  if (statsRefreshing) statsRefreshing.classList.remove("hidden");

  fetch(`${APPS_SCRIPT_URL}?action=getCheckpointStats&eventType=${encodeURIComponent(event)}&checkpoint=${encodeURIComponent(checkpoint)}`)
    .then((response) => {
      if (!response.ok) throw new Error("Network response was not ok");
      return response.json();
    })
    .then((data) => {
      if (data.success && data.stats) {
        const stats = {
          scannedCount: data.stats.Scanned,
          totalRunners: data.stats["Total Runners"],
          scannedPercentage: parseInt(data.stats.Completion.replace('%', '')) || 0
        };
        updateCheckpointStatsUI(stats);
        logDebug(`Stats loaded: ${JSON.stringify(stats)}`);
      } else {
        logDebug("No stats returned from server, falling back to local stats.");
        updateCheckpointStatsUI(calculateLocalCheckpointStats());
      }
    })
    .catch((error) => {
      logDebug(`Stats fetch failed: ${error}`);
      updateCheckpointStatsUI(calculateLocalCheckpointStats());
    })
    .finally(() => {
      if (statsRefreshing) statsRefreshing.classList.add("hidden");
      isRefreshingStats = false;
    });
}






// Add this function to fetch the list of already scanned runners
function fetchScannedRunnersList() {
  if (!checkpoint || !isOnline) return

  logDebug(`Fetching scanned runners list for ${event} at ${checkpoint}`)

  fetch(
    `${APPS_SCRIPT_URL}?action=getScannedRunners&eventType=${encodeURIComponent(event)}&checkpoint=${encodeURIComponent(checkpoint)}`,
  )
    .then((response) => response.text())
    .then((text) => {
      try {
        const data = JSON.parse(text)
        if (data.success && data.data) {
          // Clear existing set
          alreadyScannedRunners = new Set()

          // Add each scanned bib to the set
          data.data.forEach((scan) => {
            alreadyScannedRunners.add(scan.bib)
          })

          logDebug(`Loaded ${alreadyScannedRunners.size} already scanned runners`)
        }
      } catch (error) {
        logDebug(`Error parsing scanned runners response: ${error}`)
      }
    })
    .catch((error) => {
      logDebug(`Error fetching scanned runners: ${error}`)
    })
}




const eventType = typeof event !== 'undefined' ? event : "50K";
const resultsSheetName = eventType === "ASCENT" ? "ASCENT RESULTS" : "50k CHECKPOINT SCANS";  
const cacheBuster = Date.now();
const spreadsheetUrl = `https://docs.google.com/spreadsheets/d/${RESULTS_SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(resultsSheetName)}&cacheBuster=${cacheBuster}`;

  
  fetch(spreadsheetUrl)
    .then(response => response.text())
    .then(text => {
      // The response is not pure JSON, it's wrapped in a callback
      // We need to extract the JSON part
      const jsonStart = text.indexOf('{');
      const jsonEnd = text.lastIndexOf('}') + 1;
      const jsonString = text.substring(jsonStart, jsonEnd);
      return JSON.parse(jsonString);
    })
    .then(data => {
      if (data && data.table && data.table.rows) {
        const rows = data.table.rows;
        const headers = data.table.cols.map(col => col.label);
        
        logDebug(`Found spreadsheet columns: ${headers.join(', ')}`);
        
        // Find column indices using your exact column names
        const bibIndex = headers.findIndex(h => h === "BIB NUMBER");
        const checkpointIndex = headers.findIndex(h => h === "CHECKPOINT");
        
        logDebug(`Column indices found: bib=${bibIndex}, checkpoint=${checkpointIndex}`);
        
        if (bibIndex === -1 || checkpointIndex === -1) {
          logDebug(`Could not find required columns. Available: ${headers.join(', ')}`);
          throw new Error(`Could not find required columns. Available: ${headers.join(', ')}`);
        }
        
        // Process each row to find scans for this checkpoint
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i].c;
          if (row && row[bibIndex] && row[bibIndex].v && row[checkpointIndex] && row[checkpointIndex].v) {
            const bib = row[bibIndex].v.toString();
            const scanCheckpoint = row[checkpointIndex].v.toString();
            
            if (scanCheckpoint === checkpoint) {
              alreadyScannedRunners.add(bib);
              logDebug(`Found already scanned runner: Bib #${bib} at ${checkpoint}`);
            }
          }
        }
        
        logDebug(`Loaded ${alreadyScannedRunners.size} already scanned runners from spreadsheet`);
        
        // Reset processed scans for runners that no longer have entries
        // This allows them to be scanned again if their entry was deleted
        resetProcessedScansForDeletedEntries();
        
        // Now fetch runner data to get accurate total count and DNF status
        return fetchRunnerDataForStats();
      } else {
        throw new Error('Invalid spreadsheet data format');
      }
    })
    .then(() => {
      // Calculate and update stats with the fresh data
      const stats = calculateLocalCheckpointStats();
      updateCheckpointStatsUI(stats);
    })
    .catch(error => {
      logDebug('Error fetching checkpoint stats from spreadsheet: ' + error);
      // Calculate stats locally as fallback
      const stats = calculateLocalCheckpointStats();
      updateCheckpointStatsUI(stats);
    })
    .finally(() => {
      // Hide the refreshing indicator
      statsRefreshing.classList.add('hidden');
      isRefreshingStats = false;
    });



  


  

// Set up periodic refresh of checkpoint stats
function setupCheckpointStatsRefresh() {
  // Clear any existing interval
  if (checkpointStatsRefreshInterval) {
    clearInterval(checkpointStatsRefreshInterval);
  }

  // Set up new interval - refresh every 5 seconds
  checkpointStatsRefreshInterval = setInterval(() => {
    if (isOnline && checkpoint) {
      logDebug('Periodic checkpoint stats refresh');
      fetchCheckpointStatsFromSpreadsheet();
    }
  }, 5000); // Changed from 30 seconds to 5 seconds
}

// Reset processed scans for runners that no longer have entries in the results spreadsheet
function resetProcessedScansForDeletedEntries() {
  // Create a list of keys to remove
  const keysToRemove = [];

  // Check each processed scan
  for (const key in processedScans) {
    // Keys are in the format "bib-checkpoint"
    const parts = key.split('-');
    if (parts.length === 2) {
      const bib = parts[0];
      const scanCheckpoint = parts[1];
      
      // If this is for our current checkpoint and the runner is not in alreadyScannedRunners,
      // then their entry was likely deleted from the spreadsheet
      if (scanCheckpoint === checkpoint && !alreadyScannedRunners.has(bib)) {
        keysToRemove.push(key);
      }
    }
  }

  // Remove the keys
  if (keysToRemove.length > 0) {
    logDebug(`Resetting ${keysToRemove.length} processed scans for deleted entries`);
    
    keysToRemove.forEach(key => {
      delete processedScans[key];
      delete scanTimestamps[key];
      logDebug(`Reset processed scan for ${key} - entry was deleted from spreadsheet`);
    });
    
    // Save the updated processed scans
    saveProcessedScans();
    saveScanTimestamps();
  }
}

// Refresh checkpoint stats button
refreshStatsBtn.addEventListener('click', function() {
  if (isRefreshingStats) return; // Prevent multiple simultaneous refreshes

  logDebug('Manual checkpoint stats refresh requested');
  isRefreshingStats = true;
  statsRefreshing.classList.remove('hidden');

  // Clear the existing set of scanned runners to force a complete refresh
  alreadyScannedRunners = new Set();

  // Force a complete refresh of both runner data and checkpoint stats
  fetchRunnerDataForStats()
    .then(() => {
      // Then fetch checkpoint stats with a forced refresh
      fetchCheckpointStatsFromSpreadsheet();
    })
    .catch(() => {
      // If there's an error, still try to fetch checkpoint stats
      fetchCheckpointStatsFromSpreadsheet();
    });
});

// Log to debug panel
function logDebug(message) {
  const timestamp = new Date().toLocaleTimeString();
  if (debugInfo) {
    debugInfo.textContent = `[${timestamp}] ${message}\n` + debugInfo.textContent;
  }
  console.log(message);
}

// Toggle debug panel
toggleDebugBtn.addEventListener('click', function() {
  debugMode = !debugMode;
  if (debugMode) {
    debugPanel.classList.remove('hidden');
    toggleDebugBtn.textContent = 'Hide Debug Panel';
  } else {
    debugPanel.classList.add('hidden');
    toggleDebugBtn.textContent = 'Show Debug Panel';
  }
});

// Force upload pending scans
forceUploadBtn.addEventListener('click', function() {
  logDebug('Manually forcing upload of pending scans');
  uploadPendingScans(true);
});

// Refresh runner data manually
refreshRunnersBtn.addEventListener('click', function() {
  logDebug('Manually refreshing runner data');
  fetchRunnerData(true);
});

// Clear all data
clearDataBtn.addEventListener('click', function() {
  if (confirm('Are you sure you want to clear all data? This will delete all stored runner data and scans.')) {
    clearAllData();
  }
});

// Refresh connection button
refreshButton.addEventListener('click', function() {
  logDebug('Manual connection refresh requested');

  // Check connection
  const currentOnlineStatus = navigator.onLine;
  logDebug(`Current connection status: ${currentOnlineStatus ? 'online' : 'offline'}`);

  if (currentOnlineStatus) {
    showMessage('Checking for pending uploads...');
    uploadPendingScans(true);
    
    // Also refresh runner data
    fetchRunnerData(true);
    
    // Fetch already scanned runners
    fetchAlreadyScannedRunners();
  } else {
    showMessage('No internet connection available', true);
  }
});

// Clear all data from localStorage
function clearAllData() {
  try {
    localStorage.removeItem('pendingUploads');
    localStorage.removeItem('recentScans');
    localStorage.removeItem('runnersData');
    localStorage.removeItem('processedScans');
    localStorage.removeItem('scanTimestamps');
    localStorage.removeItem('uploadedScans');
    
    pendingUploads = [];
    recentScans = [];
    runnersData = {};
    processedScans = {};
    scanTimestamps = {};
    uploadedScans = {};
    alreadyScannedRunners = new Set();
    
    updatePendingUploadsUI();
    updateRecentScansUI();
    
    logDebug('All data cleared successfully');
    showMessage('All data cleared successfully');
    
    // Fetch fresh runner data
    fetchRunnerData(true);
    
    // Fetch already scanned runners
    fetchAlreadyScannedRunners();
  } catch (error) {
    logDebug('Error clearing data: ' + error);
    showMessage('Error clearing data', true);
  }
}

// Initialize the application
function init() {
  // DOM elements for installation
  const androidInstallBtn = document.getElementById("android-install-btn");
  const iosInstallBtn = document.getElementById("ios-install-btn");
  const iosInstructions = document.getElementById("ios-install-instructions");
  persistentInstallBtn = document.createElement("button");

  // Set up persistent install button
  setupPersistentInstallButton(persistentInstallBtn);

  // Set up installation instructions - pass the elements as parameters
  showAppropriateInstallInstructions(androidInstallBtn, iosInstallBtn, iosInstructions);

  // Update install prompts
  updateInstallPrompts();

  // Set up scanner screen install buttons
  const scannerAndroidInstall = document.getElementById('scanner-android-install');
  const scannerIosInstall = document.getElementById('scanner-ios-install');
  const scannerIosInstructions = document.getElementById('scanner-ios-instructions');

  if (scannerAndroidInstall) {
    scannerAndroidInstall.addEventListener('click', triggerInstall);
    // Hide Android button on iOS
    if (isIOS()) {
      scannerAndroidInstall.classList.add('hidden');
    }
  }

  if (scannerIosInstall) {
    scannerIosInstall.addEventListener('click', () => {
      scannerIosInstructions.classList.toggle('hidden');
    });
    // Hide iOS button on Android
    if (!isIOS()) {
      scannerIosInstall.classList.add('hidden');
    }
  }

  // Hide both buttons if app is already installed
  if (window.matchMedia('(display-mode: standalone)').matches || 
      window.navigator.standalone === true) {
    if (scannerAndroidInstall) scannerAndroidInstall.classList.add('hidden');
    if (scannerIosInstall) scannerIosInstall.classList.add('hidden');
  }

  // Register service worker
  registerServiceWorker();

  // Check for URL parameters (for QR code login)
  checkUrlParameters();

  // Load data from localStorage
  loadPendingScans();
  loadProcessedScans();
  loadScanTimestamps();
  loadUploadedScans();

  // Set initial online status
  isOnline = navigator.onLine;
  updateOfflineBanner();

  // Set up online/offline event listeners
  window.addEventListener('online', handleOnlineStatusChange);
  window.addEventListener('offline', handleOnlineStatusChange);

  // Check if the app is already installed
  if (window.matchMedia('(display-mode: standalone)').matches || 
      window.navigator.standalone === true) {
    logDebug("App is already installed, hiding install prompts");
    // App is already installed, hide all install prompts
    if (installPrompt) installPrompt.classList.add("hidden");
    if (persistentInstallBtn) persistentInstallBtn.classList.add("hidden");
  }

  // Check if we already have runner data in localStorage
  try {
    const storedData = localStorage.getItem('runnersData');
    if (storedData) {
      const parsedData = JSON.parse(storedData);
      if (parsedData && Object.keys(parsedData).length > 0) {
        // We have data, use it immediately
        runnersData = parsedData;
        logDebug(`Loaded ${Object.keys(runnersData).length} runners from localStorage at init`);
        
        // Check for pending uploads that need to be processed
        if (pendingUploads.length > 0) {
          logDebug(`Found ${pendingUploads.length} pending uploads at startup`);
          updatePendingUploadsUI();
        }
        
        loadingScreen.classList.add('hidden');
        checkLoginStatus();
        
        // Still fetch fresh data in the background
        setTimeout(() => {
          fetchRunnerData(true);
        }, 1000);
        
        return;
      }
    }
  } catch (error) {
    logDebug('Error loading runners data from localStorage at init: ' + error);
  }

  // If we don't have data, fetch it
  fetchRunnerData(true);

  // Check if we have pending uploads and we're online
  if (isOnline && pendingUploads.length > 0) {
    logDebug(`Found ${pendingUploads.length} pending uploads at startup - attempting to upload`);
    setTimeout(() => {
      uploadPendingScans(true);
    }, 3000);
  }
}



function startMonitoring() {
  pendingUploadsMonitorActive = true;
  lastPendingUploadsCount = pendingUploads.length;
  lastPendingUploadsData = JSON.parse(JSON.stringify(pendingUploads));
  monitorPendingUploads();
  logDebug("Started monitoring pending uploads");
}




// Update offline banner
function updateOfflineBanner() {
  if (!isOnline) {
    offlineBanner.classList.remove('hidden');
  } else {
    offlineBanner.classList.add('hidden');
  }
}

// Load uploaded scans from localStorage
function loadUploadedScans() {
  try {
    const storedUploads = localStorage.getItem('uploadedScans');
    if (storedUploads) {
      uploadedScans = JSON.parse(storedUploads);
      logDebug(`Loaded ${Object.keys(uploadedScans).length} uploaded scans from localStorage`);
    }
  } catch (error) {
    logDebug('Error loading uploaded scans from localStorage: ' + error);
    uploadedScans = {};
  }
}

// Save uploaded scans to localStorage
function saveUploadedScans() {
  try {
    localStorage.setItem('uploadedScans', JSON.stringify(uploadedScans));
  } catch (error) {
    logDebug('Error saving uploaded scans to localStorage: ' + error);
  }
}

// Load pending scans from localStorage
function loadPendingScans() {
  try {
    const savedPendingUploads = localStorage.getItem('pendingUploads');
    if (savedPendingUploads) {
      const parsed = JSON.parse(savedPendingUploads);
      if (Array.isArray(parsed)) {
        pendingUploads = parsed;
        logDebug(`Loaded ${pendingUploads.length} pending scans from localStorage`);
      } else {
        logDebug('Invalid pending uploads format in localStorage');
        pendingUploads = [];
      }
    } else {
      logDebug('No pending uploads found in localStorage');
      pendingUploads = [];
    }
  } catch (error) {
    logDebug(`Error loading pending scans: ${error}`);
    pendingUploads = [];
  }
}
  

// Save pending scans to localStorage
function savePendingScans() {
  try {
    logDebug(`Saving ${pendingUploads.length} pending scans to localStorage`);
    localStorage.setItem('pendingUploads', JSON.stringify(pendingUploads));
  } catch (error) {
    logDebug(`Error saving pending scans: ${error}`);
  }
}


// Load processed scans from localStorage
function loadProcessedScans() {
  try {
    const storedProcessed = localStorage.getItem('processedScans');
    if (storedProcessed) {
      processedScans = JSON.parse(storedProcessed);
      logDebug(`Loaded ${Object.keys(processedScans).length} processed scans from localStorage`);
    }
  } catch (error) {
    logDebug('Error loading processed scans from localStorage: ' + error);
    processedScans = {};
  }
}

// Save processed scans to localStorage
function saveProcessedScans() {
  try {
    localStorage.setItem('processedScans', JSON.stringify(processedScans));
  } catch (error) {
    logDebug('Error saving processed scans to localStorage: ' + error);
  }
}

// Load scan timestamps from localStorage
function loadScanTimestamps() {
  try {
    const storedTimestamps = localStorage.getItem('scanTimestamps');
    if (storedTimestamps) {
      scanTimestamps = JSON.parse(storedTimestamps);
      logDebug(`Loaded ${Object.keys(scanTimestamps).length} scan timestamps from localStorage`);
    }
  } catch (error) {
    logDebug('Error loading scan timestamps from localStorage: ' + error);
    scanTimestamps = {};
  }
}

// Save scan timestamps to localStorage
function saveScanTimestamps() {
  try {
    localStorage.setItem('scanTimestamps', JSON.stringify(scanTimestamps));
  } catch (error) {
    logDebug('Error saving scan timestamps to localStorage: ' + error);
  }
}

// Handle online/offline status changes
function handleOnlineStatusChange() {
  const wasOnline = isOnline;
  isOnline = navigator.onLine;
  
  logDebug(`Connection status changed: ${wasOnline ? 'online' : 'offline'} -> ${isOnline ? 'online' : 'offline'}`);
  
  updateConnectionStatus();
  updateOfflineBanner();
  
  if (isOnline && !wasOnline) {
    // We just came back online
    showMessage('Connection restored! Checking for pending uploads...');
    
    // Try to upload any pending scans
    if (pendingUploads.length > 0) {
      setTimeout(() => {
        uploadPendingScans(true);
      }, 1000);
    }
    
    // Refresh runner data
    fetchRunnerData(true);
    
    // Fetch already scanned runners
    fetchAlreadyScannedRunners();
  }
}

// Update connection status display
function updateConnectionStatus() {
  if (isOnline) {
    statusIcon.style.color = '#28a745';
    statusText.textContent = 'CONNECTED';
    statusText.style.color = '#28a745';
  } else {
    statusIcon.style.color = '#dc3545';
    statusText.textContent = 'OFFLINE';
    statusText.style.color = '#dc3545';
  }
}
  

// CHANGE THIS BLOCK (approximately line 1200-1250)
function checkLoginStatus() {
  const savedEvent = localStorage.getItem('tigerClawEvent');
  const savedCheckpoint = localStorage.getItem('tigerClawCheckpoint');
  
  if (savedEvent && savedCheckpoint) {
    event = savedEvent;
    checkpoint = savedCheckpoint;
    
    // Set the location select value if the user returns to the login screen
    const combinedValue = `${savedEvent}|${savedCheckpoint}`;
    // Try to find and select the matching option
    const options = Array.from(locationSelect.options);
    const matchingOption = options.find(option => option.value === combinedValue);
    if (matchingOption) {
      locationSelect.value = combinedValue;
    }
    
    showScannerScreen();
    
    // Fetch already scanned runners at this checkpoint
    fetchAlreadyScannedRunners();
    
    // Start periodic upload attempts
    startPeriodicUploadAttempts();
  } else {
    loginScreen.classList.remove('hidden');
    loadingScreen.classList.add('hidden');
  }
}

  



// Update the fetchRunnerData function
function fetchRunnerData(forceRefresh = false) {
  if (isLoadingRunnerData) {
    logDebug("Already loading runner data, skipping duplicate request");
    return;
  }
  
  // Set loading flag
  isLoadingRunnerData = true;
  dataLoadAttempted = true;
  
  // Show loading screen if we don't have any data yet
  if (Object.keys(runnersData).length === 0) {
    loadingScreen.classList.remove("hidden");
    loginScreen.classList.add("hidden");
    scannerScreen.classList.add("hidden");
  }
  
  // Hide any previous error
  loadingError.classList.add("hidden");
  
  // Log the current event to debug
  logDebug(`Fetching runner data for event: "${event}"`);
  
  // Set a timeout to show an error if the data doesn't load
  if (dataLoadTimeoutId) {
    clearTimeout(dataLoadTimeoutId);
  }
  
  dataLoadTimeoutId = setTimeout(() => {
    if (isLoadingRunnerData) {
      logDebug("Data loading timed out");
      isLoadingRunnerData = false;
      
      // Show error if we don't have any data
      if (Object.keys(runnersData).length === 0) {
        loadingError.classList.remove("hidden");
      } else {
        // We have some data, so continue with what we have
        loadingScreen.classList.add("hidden");
        checkLoginStatus();
      }
    }
  }, DATA_LOAD_TIMEOUT);
  
  // Add a cache-busting parameter to ensure we get fresh data
  const cacheBuster = new Date().getTime();
  
  // Use the API to get runner data for the specific event
  fetch(`${APPS_SCRIPT_URL}?action=getRunnerData&eventType=${encodeURIComponent(event)}&cacheBuster=${cacheBuster}`)
    .then(response => {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.json();
    })
    .then(data => {
      logDebug(`Received runner data response: ${JSON.stringify(data).substring(0, 200)}...`);
      
      if (data && data.success && data.data && Array.isArray(data.data)) {
        const runners = data.data;
        const runnerMap = {};
        
        // Process each runner
        runners.forEach(runner => {
          const bib = runner.bibNumber;
          const name = runner.name || "Unknown";
          const status = runner.status || "Active";
          const dnf = status === "DNF" || status === "DNS";
          
          runnerMap[bib] = {
            name: name,
            dnf: dnf,
            event: event // Store the event with each runner
          };
        });
        
        if (Object.keys(runnerMap).length === 0) {
          throw new Error(`No runner data found for event: ${event}`);
        }
        
        // Update the last DNF check timestamp
        lastDnfCheck = Date.now();
        
        runnersData = runnerMap;
        localStorage.setItem(`runnersData_${event}`, JSON.stringify(runnersData));
        logDebug(`Loaded ${Object.keys(runnersData).length} runners for event: ${event}`);
        
        // Clear the timeout
        if (dataLoadTimeoutId) {
          clearTimeout(dataLoadTimeoutId);
          dataLoadTimeoutId = null;
        }
        
        // Hide loading screen and show appropriate screen
        loadingScreen.classList.add("hidden");
        checkLoginStatus();
        
        // Set up runner data refresh interval
        setupRunnerDataRefresh();
        
        // Update checkpoint stats with fresh data
        if (checkpoint) {
          fetchCheckpointStats(true);
        }
      } else {
        throw new Error("Invalid runner data format or empty response");
      }
    })
    .catch(error => {
      logDebug("Error fetching runner data: " + error);
      
      // If we have cached data, use that
      try {
        const storedData = localStorage.getItem(`runnersData_${event}`);
        if (storedData) {
          const parsedData = JSON.parse(storedData);
          if (parsedData && Object.keys(parsedData).length > 0) {
            runnersData = parsedData;
            logDebug(`Using ${Object.keys(runnersData).length} runners from localStorage after fetch error`);
            
            // Hide loading screen and show appropriate screen
            loadingScreen.classList.add("hidden");
            checkLoginStatus();
            return;
          }
        }
      } catch (e) {
        logDebug("Error loading runners data from localStorage: " + e);
      }
      
      // Show error if we don't have any data
      if (Object.keys(runnersData).length === 0) {
        loadingError.classList.remove("hidden");
      } else {
        // We have some data, so continue with what we have
        loadingScreen.classList.add("hidden");
        checkLoginStatus();
      }
    })
    .finally(() => {
      isLoadingRunnerData = false;
    });
}

  

// Set up periodic refresh of runner data
function setupRunnerDataRefresh() {
  // Implementation for setupRunnerDataRefresh
  console.log("setupRunnerDataRefresh function called")
}


  
  

  


  
function updateCheckpointStatsUI(stats) {
  if (!stats) return;
  
  // Update the stats text
  statsText.textContent = `${stats.scannedCount} of ${stats.totalRunners} active runners scanned (${stats.scannedPercentage}%)`;
  
  // Update the progress bar
  progressBarFill.style.width = `${stats.scannedPercentage}%`;
  
  // Update the scanned and remaining counts
  scannedCount.textContent = `${stats.scannedCount} scanned`;
  remainingCount.textContent = `${stats.totalRunners - stats.scannedCount} remaining`;
}

  

// Scan button click handler
scanButton.addEventListener('click', function() {
  if (isScanning) {
    stopScanning();
  } else {
    startScanning();
  }
});

// Start scanning
function startScanning() {
  if (isScanning) return;
  
  isScanning = true;
  scanButton.textContent = 'STOP SCANNING';
  scanButton.style.backgroundColor = '#dc3545';
  scannerContainer.classList.remove('hidden');
  
  // Add scanner-active class to body for styling
  document.body.classList.add('scanner-active');
  
  // Try HTML5 QR Code scanner first
  try {
    if (!html5QrCode) {
      html5QrCode = new Html5Qrcode("qr-reader");
    }
    
    // Show camera loading indicator
    cameraLoading.classList.remove('hidden');
    
    // Set a timeout to fall back to native camera if HTML5QrCode takes too long
    cameraStartTimeout = setTimeout(() => {
      if (html5QrCode && !html5QrCode.isScanning) {
        logDebug('HTML5QrCode camera start timed out, falling back to native camera');
        stopHtml5QrScanner();
        startNativeCamera();
      }
    }, 10000);
    
    const qrCodeSuccessCallback = (decodedText, decodedResult) => {
      handleScanResult(decodedText);
    };
    
    const qrCodeErrorCallback = (errorMessage, error) => {
      // Ignore errors during scanning
    };
    
    const config = {
      fps: 10,
      qrbox: { width: 250, height: 250 },
      aspectRatio: 1.0,
      disableFlip: false,
      videoConstraints: {
        facingMode: "environment"
      }
    };
    
    html5QrCode.start(
      { facingMode: "environment" },
      config,
      qrCodeSuccessCallback,
      qrCodeErrorCallback
    ).then(() => {
      // Camera started successfully
      cameraLoading.classList.add('hidden');
      if (cameraStartTimeout) {
        clearTimeout(cameraStartTimeout);
        cameraStartTimeout = null;
      }
    }).catch((err) => {
      logDebug('Error starting HTML5QrCode camera: ' + err);
      // Fall back to native camera
      startNativeCamera();
    });
  } catch (error) {
    logDebug('Error initializing HTML5QrCode: ' + error);
    // Fall back to native camera
    startNativeCamera();
  }
}

// Start native camera as fallback
function startNativeCamera() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    logDebug('Native camera API not supported');
    showMessage('Camera not supported on this device', true);
    stopScanning();
    return;
  }
  
  useNativeCamera = true;
  scannerContainer.classList.add('hidden');
  nativeCameraContainer.classList.remove('hidden');
  
  navigator.mediaDevices.getUserMedia({
    video: {
      facingMode: 'environment',
      width: { ideal: 1280 },
      height: { ideal: 720 }
    }
  }).then(stream => {
    nativeCameraStream = stream;
    nativeCameraVideo.srcObject = stream;
    nativeCameraVideo.play();
    
    // Set up canvas for QR code detection
    const canvas = nativeCameraCanvas;
    const context = canvas.getContext('2d');
    
    // Process video frames
    const scanFrame = () => {
      if (!isScanning || !useNativeCamera) return;
      
      if (nativeCameraVideo.readyState === nativeCameraVideo.HAVE_ENOUGH_DATA) {
        canvas.width = nativeCameraVideo.videoWidth;
        canvas.height = nativeCameraVideo.videoHeight;
        context.drawImage(nativeCameraVideo, 0, 0, canvas.width, canvas.height);
        
        // Use a library like jsQR here to detect QR codes
        // For now, we'll just use manual entry
      }
      
      requestAnimationFrame(scanFrame);
    };
    
    scanFrame();
  }).catch(error => {
    logDebug('Error accessing camera: ' + error);
    showMessage('Could not access camera. Please use manual entry.', true);
    useNativeCamera = false;
    nativeCameraContainer.classList.add('hidden');
  });
}

// Stop scanning
function stopScanning() {
  isScanning = false;
  scanButton.textContent = 'START SCANNING';
  scanButton.style.backgroundColor = '#28a745';
  scannerContainer.classList.add('hidden');
  nativeCameraContainer.classList.add('hidden');
  
  // Remove scanner-active class from body
  document.body.classList.remove('scanner-active');
  
  // Stop HTML5 QR Code scanner
  stopHtml5QrScanner();
  
  // Stop native camera
  stopNativeCamera();
}

// Stop HTML5 QR Code scanner
function stopHtml5QrScanner() {
  if (html5QrCode && html5QrCode.isScanning) {
    html5QrCode.stop().catch(err => {
      logDebug('Error stopping HTML5QrCode: ' + err);
    });
  }
}

// Stop native camera
function stopNativeCamera() {
  if (nativeCameraStream) {
    nativeCameraStream.getTracks().forEach(track => {
      track.stop();
    });
    nativeCameraStream = null;
  }
  
  if (nativeCameraVideo) {
    nativeCameraVideo.srcObject = null;
  }
  
  useNativeCamera = false;
}

// Handle scan result
function handleScanResult(scannedText) {
  // Check if the scanned text is a valid bib number
  const bibNumber = extractBibNumber(scannedText);
  
  if (!bibNumber) {
    showMessage('Invalid QR code. Please try again.', true);
    return;
  }
  
  // Process the scan
  processScan(bibNumber);
}

// Extract bib number from scanned text
function extractBibNumber(scannedText) {
  // Try to extract a number from the scanned text
  const matches = scannedText.match(/\d+/);
  if (matches && matches.length > 0) {
    return matches[0];
  }
  return null;
}

// Manual submit button click handler
manualSubmitButton.addEventListener('click', function() {
  const bibNumber = bibInput.value.trim();
  
  if (!bibNumber) {
    showMessage('Please enter a bib number', true);
    return;
  }
  
  // Process the scan
  processScan(bibNumber);
  
  // Clear the input
  bibInput.value = '';
});


  
function processScan(bibNumber) {
  // Log the current event and checkpoint for debugging
  logDebug(`Processing scan for bib #${bibNumber} at ${checkpoint} for event ${event}`);
  
  // Check if this is a valid bib number
  if (!runnersData[bibNumber]) {
    showMessage(`Bib #${bibNumber} not found in ${event} runner data`, true);
    return;
  }
  
  // Check if the runner is marked as DNF
  if (runnersData[bibNumber].dnf) {
    showMessage(`Bib #${bibNumber} is marked as DNF`, true);
    return;
  }
  
  // Create scan key
  const scanKey = `${bibNumber}-${checkpoint}`;
  
  // Check if we've already processed this scan
  let isRescan = false;
  if (processedScans[scanKey]) {
    isRescan = true;
    const lastScanTime = new Date(scanTimestamps[scanKey]).toLocaleTimeString();
    logDebug(`Rescan of Bib #${bibNumber} (previous scan at ${lastScanTime})`);
    
    // Remove previous scan from recent scans
    recentScans = recentScans.filter(scan => !(scan.bib === bibNumber && scan.checkpoint === checkpoint));
    
    // Find and remove previous scan from pending uploads
    const previousScanIndex = pendingUploads.findIndex(scan => scan.bib === bibNumber && scan.checkpoint === checkpoint);
    if (previousScanIndex !== -1) {
      pendingUploads.splice(previousScanIndex, 1);
      savePendingScans();
    }
  }
  
  // Mark as processed and update timestamp
  processedScans[scanKey] = true;
  scanTimestamps[scanKey] = new Date().toISOString();
  saveProcessedScans();
  saveScanTimestamps();
  
  // Add to already scanned runners set
  alreadyScannedRunners.add(bibNumber);
  
  // Create scan record
  const timestamp = new Date().toISOString();
  
  // Format a human-readable finish time (HH:MM:SS) for display
  const now = new Date();
  const finishTime = now.toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  });
  
  // Create the scan object with the correct event type
  const scan = {
    bib: bibNumber,
    name: runnersData[bibNumber].name,
    event: event, // Use the currently selected event
    checkpoint: checkpoint,
    timestamp: timestamp,
    finishTime: finishTime, // Add formatted finish time
    status: event === "ASCENT" ? "FINISHED" : undefined, // Add status for ASCENT
    uploaded: false,
    isRescan: isRescan
  };

  logDebug(`Created scan object: ${JSON.stringify(scan)}`);

  

  
  // Add to recent scans
  recentScans.unshift(scan);
  if (recentScans.length > 50) {
    recentScans.pop();
  }
  
  // Save recent scans to localStorage
  try {
    localStorage.setItem('recentScans', JSON.stringify(recentScans));
  } catch (error) {
    logDebug('Error saving recent scans to localStorage: ' + error);
  }
  
  // Update UI
  updateRecentScansUI();
  
  // Show success message
  if (isRescan) {
    showMessage(`Updated scan for Bib #${bibNumber}: ${runnersData[bibNumber].name}`);
  } else {
    showMessage(`Scanned Bib #${bibNumber}: ${runnersData[bibNumber].name}`);
  }
  
  // Flash the overlay
  flashOverlay.style.display = 'block';
  setTimeout(() => {
    flashOverlay.style.display = 'none';
  }, 300);
  
  // Add to pending uploads
  pendingUploads.push(scan);
  savePendingScans();
  updatePendingUploadsUI();
  
  // Try to upload immediately if online
  if (isOnline) {
    uploadPendingScans(true); // Force upload
  }
  
  // Update checkpoint stats
  fetchCheckpointStats();
}

  

  
// Update recent scans UI
function updateRecentScansUI() {
  scansList.innerHTML = '';
  
  if (recentScans.length === 0) {
    scansList.innerHTML = '<div class="scan-item">No scans yet</div>';
    return;
  }
  
  recentScans.forEach(scan => {
    const scanTime = new Date(scan.timestamp).toLocaleTimeString();
    const scanItem = document.createElement('div');
    scanItem.className = 'scan-item';
    
    const bibSpan = document.createElement('span');
    bibSpan.className = 'scan-bib';
    bibSpan.textContent = `#${scan.bib}: ${scan.name}`;
    
    // Check if runner is now marked as DNF
    if (runnersData[scan.bib] && runnersData[scan.bib].dnf) {
      const dnfIndicator = document.createElement('span');
      dnfIndicator.className = 'dnf-indicator';
      dnfIndicator.textContent = 'DNF';
      bibSpan.appendChild(dnfIndicator);
    }
    
    const timeSpan = document.createElement('span');
    timeSpan.className = 'scan-time';
    timeSpan.textContent = scanTime;
    
    scanItem.appendChild(bibSpan);
    scanItem.appendChild(timeSpan);
    scansList.appendChild(scanItem);
  });
}

function updatePendingUploadsUI() {
  pendingUploadsContainer.innerHTML = '';
  
  if (pendingUploads.length === 0) {
    pendingUploadsContainer.classList.add('hidden');
    return;
  }
  
  pendingUploadsContainer.classList.remove('hidden');
  pendingUploadsContainer.innerHTML = `
    <p>${pendingUploads.length} scan${pendingUploads.length === 1 ? '' : 's'} pending upload</p>
  `;
}


function uploadPendingScans(force = false) {
  logDebug(`uploadPendingScans() called. checkpoint=${checkpoint}, event=${event}`);

  if (!isOnline || pendingUploads.length === 0) {
    return;
  }
  
  // Allow forced uploads to bypass the isUploadingPendingScans check
  if (!force && isUploadingPendingScans) {
    return;
  }
  
  // Set uploading flag
  isUploadingPendingScans = true;
  
  logDebug(`Uploading ${pendingUploads.length} pending scans`);
  showMessage(`Uploading ${pendingUploads.length} scans...`);
  
  // Create a deep copy of the pending uploads to avoid reference issues
  const uploadsToProcess = JSON.parse(JSON.stringify(pendingUploads));
  
  // Log all scans for debugging
  logDebug(`All scans to upload: ${JSON.stringify(uploadsToProcess)}`);
  
  // Group scans by event type
  const ascentScans = uploadsToProcess.filter(scan => scan.event === "ASCENT");
  const fiftyKScans = uploadsToProcess.filter(scan => scan.event === "50K");
  
  logDebug(`Grouped scans: ${ascentScans.length} ASCENT scans and ${fiftyKScans.length} 50K scans`);
  
  // Create separate upload promises for each event type
  const uploadPromises = [];
  const successfulUploads = [];
  
  // Upload ASCENT scans
  if (ascentScans.length > 0) {
    logDebug(`Preparing to upload ${ascentScans.length} ASCENT scans to ASCENT RESULTS sheet`);
    
    const ascentUploadData = {
      action: "recordScans",
      eventType: "ASCENT",
      sheetName: "ASCENT RESULTS",
      scans: ascentScans,
      columnMappings: {
        timestamp: "TIMESTAMP",
        bib: "BIB NUMBER",
        name: "RUNNER NAME",
        finishTime: "FINISH TIME",
        status: "STATUS"
      }
    };
    
    logDebug(`ASCENT upload data: ${JSON.stringify(ascentUploadData)}`);
    
    uploadPromises.push(
      fetch(APPS_SCRIPT_URL, {
        method: 'POST',
        mode: 'no-cors',
        cache: 'no-cache',
        headers: {
          'Content-Type': 'text/plain;charset=utf-8',
        },
        body: JSON.stringify(ascentUploadData)
      }).then(() => {
        logDebug('ASCENT upload successful (assumed)');
        // Mark these scans as successfully uploaded
        ascentScans.forEach(scan => {
          successfulUploads.push(`${scan.bib}-${scan.checkpoint}`);
        });
        return ascentScans.length;
      }).catch(error => {
        logDebug('Error uploading ASCENT scans: ' + error);
        return 0;
      })
    );
  }
  
  // Upload 50K scans
  if (fiftyKScans.length > 0) {
    logDebug(`Preparing to upload ${fiftyKScans.length} 50K scans to 50k CHECKPOINT SCANS sheet`);
    
    const fiftyKUploadData = {
      action: "recordScans",
      eventType: "50K",
      sheetName: "50k CHECKPOINT SCANS",
      scans: fiftyKScans,
      columnMappings: {
        timestamp: "TIMESTAMP",
        bib: "BIB NUMBER",
        name: "RUNNER NAME",
        checkpoint: "CHECKPOINT",
        event: "EVENT"
      }
    };
    
    logDebug(`50K upload data: ${JSON.stringify(fiftyKUploadData)}`);
    
    uploadPromises.push(
      fetch(APPS_SCRIPT_URL, {
        method: 'POST',
        mode: 'no-cors',
        cache: 'no-cache',
        headers: {
          'Content-Type': 'text/plain;charset=utf-8',
        },
        body: JSON.stringify(fiftyKUploadData)
      }).then(() => {
        logDebug('50K upload successful (assumed)');
        // Mark these scans as successfully uploaded
        fiftyKScans.forEach(scan => {
          successfulUploads.push(`${scan.bib}-${scan.checkpoint}`);
        });
        return fiftyKScans.length;
      }).catch(error => {
        logDebug('Error uploading 50K scans: ' + error);
        return 0;
      })
    );
  }
  
  // Process all upload promises
  Promise.all(uploadPromises)
    .then(results => {
      const totalUploaded = results.reduce((sum, count) => sum + count, 0);
      logDebug(`Successfully uploaded ${totalUploaded} scans`);
      showMessage(`${totalUploaded} scans uploaded successfully`);
      
      // Only remove the successfully uploaded scans from pendingUploads
      if (successfulUploads.length > 0) {
        logDebug(`Removing ${successfulUploads.length} successfully uploaded scans from pending list`);
        
        // Create a new array without the successfully uploaded scans
        const remainingUploads = pendingUploads.filter(scan => {
          const scanKey = `${scan.bib}-${scan.checkpoint}`;
          return !successfulUploads.includes(scanKey);
        });
        
        logDebug(`Pending uploads before: ${pendingUploads.length}, after: ${remainingUploads.length}`);
        
        // Update the pendingUploads array
        pendingUploads = remainingUploads;
        savePendingScans();
      }

      logDebug(`Uploading to ASCENT RESULTS sheet`);
      logDebug(`Uploading to 50k CHECKPOINT SCANS sheet`);

      
      // Update UI
      updatePendingUploadsUI();
      
      // Fetch fresh checkpoint stats
      fetchCheckpointStats(true);
    })
    .catch(error => {
      logDebug('Error in upload process: ' + error);
      showMessage('Upload failed. Will retry later.', true);
    })
    .finally(() => {
      isUploadingPendingScans = false;
    });
}
  
  

// Show message
function showMessage(message, isError = false) {
  messageDisplay.textContent = message;
  messageDisplay.classList.remove('hidden');
  
  if (isError) {
    messageDisplay.style.color = '#dc3545';
  } else {
    messageDisplay.style.color = '#28a745';
  }
  
  // Hide message after 3 seconds
  setTimeout(() => {
    messageDisplay.classList.add('hidden');
  }, 3000);
}

// Logout button click handler
logoutButton.addEventListener('click', function() {
  if (confirm('Are you sure you want to logout?')) {
    // Stop scanning if active
    if (isScanning) {
      stopScanning();
    }
    
// Clear event and checkpoint
event = '';
checkpoint = '';
localStorage.removeItem('tigerClawEvent');
localStorage.removeItem('tigerClawCheckpoint');

// Reset the location select
locationSelect.value = '';
    
    
    // Show login screen
    scannerScreen.classList.add('hidden');
    loginScreen.classList.remove('hidden');
    
    // Clear form fields
locationSelect.value = '';
passwordInput.value = '';
    
    // Clear any error messages
    loginError.classList.add('hidden');
    
    // Clear intervals
    if (checkpointStatsRefreshInterval) {
      clearInterval(checkpointStatsRefreshInterval);
    }
    
    if (periodicUploadInterval) {
      clearInterval(periodicUploadInterval);
    }
  }
});

// Initialize the application when the DOM is loaded
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
