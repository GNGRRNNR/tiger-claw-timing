<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üèÉ</text></svg>">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com;">
<meta name="theme-color" content="#28a745">
  <!-- Add these to your <head> section -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Tiger Claw">
<link rel="apple-touch-icon" href="icons/icon-192x192.png">

<link rel="manifest" href="manifest.json">
<title>Tiger Claw Timing System</title>
<style>
/* Basic styling */
* {
box-sizing: border-box;
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}

#tiger-claw-app {
max-width: 500px;
margin: 0 auto;
padding: 20px;
background-color: #f9f9f9;
border-radius: 10px;
box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.app-header {
text-align: center;
margin-bottom: 20px;
}

.app-header h1 {
color: #1e7e34;
margin-bottom: 5px;
}

.form-group {
margin-bottom: 15px;
}

label {
display: block;
margin-bottom: 5px;
font-weight: bold;
}

select, input, button {
width: 100%;
padding: 10px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 16px;
}

button {
background-color: #28a745;
color: white;
border: none;
cursor: pointer;
font-weight: bold;
margin-top: 10px;
padding: 12px;
}

button:hover {
background-color: #218838;
}

button:disabled {
background-color: #6c757d;
cursor: not-allowed;
}

.error-message {
color: #dc3545;
margin-top: 5px;
font-size: 14px;
}

.success-message {
color: #28a745;
margin-top: 5px;
font-size: 14px;
}

.connection-status {
display: flex;
align-items: center;
justify-content: center;
margin-bottom: 10px;
font-size: 14px;
}

.status-connected {
color: #28a745;
}

.status-disconnected {
color: #dc3545;
}

.status-icon {
margin-right: 5px;
}

.hidden {
display: none !important;
}

.scanner-container {
position: relative;
margin: 10px 0;
/* Make scanner more prominent and higher in the view */
max-width: 350px;
margin-left: auto;
margin-right: auto;
}

/* QR reader container - let it use natural aspect ratio */
#qr-reader {
width: 100% !important;
border: none !important;
box-shadow: none !important;
position: relative;
overflow: hidden;
border-radius: 8px;
background-color: transparent !important;
}

/* Fix for black rectangle */
#qr-reader__dashboard_section_csr {
background: transparent !important;
padding: 0 !important;
display: none !important;
}

#qr-reader__scan_region {
background: transparent !important;
}

#qr-reader video {
max-height: 300px !important;
object-fit: cover !important;
}

/* Make sure only one camera view is visible */
#qr-reader__scan_region video:nth-child(n+2) {
display: none !important;
}

#qr-reader__status_span {
display: none !important;
background-color: #f0fdf4 !important;
color: #166534 !important;
}

/* Targeting overlay - adapt to the actual camera view */
.targeting-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 5;
}

.targeting-overlay::before {
content: '';
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 70%;
height: 70%;
border: 2px dashed #28a745;
border-radius: 8px;
}

.targeting-overlay::after {
content: '';
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 20px;
height: 20px;
border: 2px solid #28a745;
border-radius: 50%;
}

.flash-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(40, 167, 69, 0.7);
z-index: 9999;
display: none;
}

.pending-uploads {
background-color: #fff3cd;
color: #856404;
padding: 10px;
border-radius: 5px;
margin-top: 15px;
font-size: 14px;
}

.loading-spinner {
display: inline-block;
width: 20px;
height: 20px;
border: 3px solid rgba(0, 0, 0, 0.1);
border-radius: 50%;
border-top-color: #28a745;
animation: spin 1s ease-in-out infinite;
margin-right: 10px;
}

@keyframes spin {
to { transform: rotate(360deg); }
}

/* QR Scanner customizations */
#qr-reader__scan_region {
min-height: 300px;
}

/* Hide unnecessary elements */
#qr-reader__dashboard_section_swaplink,
#qr-reader__dashboard_section_csr button,
#qr-reader__camera_selection,
#qr-reader__filescan_input,
#qr-reader__filescan_input + span {
display: none !important;
}

/* Hide the built-in QR scanner border */
#qr-reader video {
border: none !important;
}

/* Hide the built-in QR scanner reticule */
#qr-reader__scan_region_highlight {
display: none !important;
}

/* Recent scans list */
.recent-scans {
margin-top: 20px;
border-top: 1px solid #ddd;
padding-top: 10px;
}

.recent-scans h3 {
margin-top: 0;
font-size: 16px;
}

.scan-item {
padding: 8px;
border-bottom: 1px solid #eee;
display: flex;
justify-content: space-between;
}

.scan-item:last-child {
border-bottom: none;
}

.scan-bib {
font-weight: bold;
}

.scan-time {
color: #666;
font-size: 14px;
}

/* Debug panel */
.debug-panel {
margin-top: 20px;
padding: 10px;
background-color: #f8f9fa;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 12px;
}

.debug-panel h4 {
margin-top: 0;
margin-bottom: 5px;
}

.debug-panel pre {
margin: 0;
white-space: pre-wrap;
word-break: break-all;
}

/* Native camera fallback */
#native-camera-container {
display: flex;
flex-direction: column;
align-items: center;
margin: 20px 0;
}

#native-camera-video {
width: 100%;
max-width: 350px;
border-radius: 8px;
background-color: #000;
object-fit: cover;
}

#native-camera-canvas {
display: none;
}

/* Camera instructions */
.camera-instructions {
text-align: center;
margin: 10px 0;
font-size: 14px;
color: #666;
}

/* Manual entry section - make it more compact when scanner is active */
.scanner-active .manual-entry-section {
margin-top: 10px;
padding-top: 10px;
border-top: 1px solid #ddd;
}

.scanner-active .manual-entry-section h2 {
font-size: 16px;
margin-top: 0;
margin-bottom: 10px;
}

/* Camera loading indicator */
.camera-loading {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
background-color: rgba(0, 0, 0, 0.7);
color: white;
border-radius: 8px;
z-index: 10;
}

.camera-loading .spinner {
width: 40px;
height: 40px;
border: 4px solid rgba(255, 255, 255, 0.3);
border-radius: 50%;
border-top-color: white;
animation: spin 1s ease-in-out infinite;
margin-bottom: 10px;
}

/* Center connection status and refresh button */
.connection-container {
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
margin-bottom: 15px;
}

#refresh-button {
background-color: #28a745;
margin: 5px auto;
display: block;
width: auto;
font-size: 12px;
padding: 5px 10px;
max-width: 200px;
}

/* Checkpoint stats */
.checkpoint-stats {
background-color: #e9f7ef;
border-radius: 5px;
padding: 10px;
margin: 10px 0;
text-align: center;
font-size: 14px;
}

.checkpoint-stats .progress-bar {
height: 10px;
background-color: #e0e0e0;
border-radius: 5px;
margin: 5px 0;
overflow: hidden;
}

.checkpoint-stats .progress-bar-fill {
height: 100%;
background-color: #28a745;
border-radius: 5px;
transition: width 0.5s ease;
}

.checkpoint-stats .stats-numbers {
display: flex;
justify-content: space-between;
font-size: 12px;
color: #666;
}

.checkpoint-stats .refresh-stats {
background-color: transparent;
color: #28a745;
border: 1px solid #28a745;
padding: 5px 10px;
font-size: 12px;
margin-top: 5px;
cursor: pointer;
}

.checkpoint-stats .refresh-stats:hover {
background-color: #f0f9f2;
}

/* DNF indicator */
.dnf-indicator {
background-color: #dc3545;
color: white;
padding: 2px 5px;
border-radius: 3px;
font-size: 10px;
margin-left: 5px;
}

/* Loading error message */
.loading-error {
color: #dc3545;
margin-top: 10px;
text-align: center;
}

.loading-error button {
background-color: #dc3545;
margin-top: 10px;
padding: 8px 15px;
font-size: 14px;
width: auto;
display: inline-block;
}

/* Stats refreshing indicator */
.stats-refreshing {
display: inline-block;
width: 12px;
height: 12px;
border: 2px solid rgba(40, 167, 69, 0.3);
border-radius: 50%;
border-top-color: #28a745;
animation: spin 1s ease-in-out infinite;
margin-left: 5px;
}

/* Offline mode banner */
.offline-banner {
background-color: #dc3545;
color: white;
text-align: center;
padding: 5px;
font-weight: bold;
margin-bottom: 10px;
border-radius: 5px;
}

/* Admin section */
#admin-section {
margin-top: 20px;
padding: 15px;
background-color: #f8f9fa;
border: 1px solid #ddd;
border-radius: 5px;
}

#admin-section h3 {
margin-top: 0;
margin-bottom: 15px;
}

/* Install prompt */
.install-prompt {
background-color: #e9f7ef;
border: 1px solid #28a745;
border-radius: 5px;
padding: 10px;
margin: 10px 0;
text-align: center;
}

.install-btn {
background-color: #28a745;
color: white;
border: none;
border-radius: 5px;
padding: 8px 15px;
font-size: 14px;
margin-top: 10px;
cursor: pointer;
}

/* Enhanced Install Prompt Styles */
.install-prompt {
  background-color: #e9f7ef;
  border: 2px solid #28a745;
  border-radius: 8px;
  padding: 15px;
  margin: 15px 0;
  text-align: center;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.install-btn {
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  font-size: 16px;
  font-weight: bold;
  margin-top: 10px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.install-btn:hover {
  background-color: #218838;
}

/* Persistent Install Button */
.persistent-install-btn {
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 8px 15px;
  font-size: 14px;
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 100;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

/* Download Section */
.download-section {
  background-color: #f8f9fa;
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 15px;
  margin: 20px 0;
  text-align: center;
}

.download-section h3 {
  color: #1e7e34;
  margin-top: 0;
  margin-bottom: 10px;
}

.download-section p {
  margin-bottom: 15px;
  font-size: 14px;
}

.platform-buttons {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
}

.platform-button {
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 5px;
  padding: 10px 15px;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 120px;
}

.platform-button:hover {
  background-color: #218838;
}

.platform-icon {
  margin-right: 8px;
  font-size: 18px;
}

/* iOS-specific install instructions */
.ios-instructions {
  text-align: left;
  margin: 15px auto;
  max-width: 280px;
  font-size: 14px;
}

.ios-instructions ol {
  padding-left: 20px;
}

.ios-instructions li {
  margin-bottom: 8px;
}

  
</style>
</head>
<body>
<div id="flash-overlay" class="flash-overlay"></div>
<div id="tiger-claw-app">
<!-- Offline Banner -->
<div id="offline-banner" class="offline-banner hidden">
  You are currently offline. Scans will be saved and uploaded when connection is restored.
</div>

<!-- Install Prompt -->
<div id="install-prompt" class="install-prompt hidden">
  Add this app to your home screen for better offline access
  <button id="install-btn" class="install-btn">Install App</button>
</div>

<!-- Loading Screen -->
<div id="loading-screen">
<div class="app-header">
  <h1>TIGER CLAW TIMING SYSTEM</h1>
  <p>Loading runner data...</p>
  <div class="loading-spinner"></div>
  <div id="loading-error" class="loading-error hidden">
    <p>Error loading runner data. Please try again.</p>
    <button id="retry-loading">Retry</button>
  </div>
</div>
</div>

<!-- Login Screen -->
<div id="login-screen" class="hidden">
<div class="app-header">
  <h1>TIGER CLAW TIMING SYSTEM</h1>
</div>

<form id="login-form">
  <div class="form-group">
    <label for="checkpoint-select">Select Checkpoint</label>
    <select id="checkpoint-select">
      <option value="">Select checkpoint</option>
      <option value="GREEN CHECKPOINT">GREEN CHECKPOINT</option>
      <option value="PINK LOOP TOP">PINK LOOP TOP</option>
      <option value="PINK LOOP BOTTOM">PINK LOOP BOTTOM</option>
      <option value="YELLOW LOOP TOP">YELLOW LOOP TOP</option>
      <option value="YELLOW LOOP BOTTOM">YELLOW LOOP BOTTOM</option>
      <option value="WHITE LOOP TOP">WHITE LOOP TOP</option>
      <option value="WHITE LOOP BOTTOM">WHITE LOOP BOTTOM</option>
      <option value="RED CHECKPOINT">RED CHECKPOINT</option>
      <option value="FINISHLINE">FINISHLINE</option>
    </select>
  </div>
  
  <div class="form-group">
    <label for="password-input">Password</label>
    <input type="password" id="password-input" placeholder="Enter password">
    <div id="login-error" class="error-message hidden"></div>
  </div>
  
  <button type="submit" id="login-button">Login</button>
</form>

<!-- Download Section (add this to the login screen) -->
<div class="download-section">
  <h3>üì± Download Tiger Claw Timing App</h3>
  <p>Install this app on your device for offline access and faster scanning</p>
  
  <div class="platform-buttons">
    <button id="android-install-btn" class="platform-button">
      <span class="platform-icon">ü§ñ</span> Android
    </button>
    <button id="ios-install-btn" class="platform-button">
      <span class="platform-icon">üçé</span> iPhone/iPad
    </button>
  </div>
  
  <div id="ios-install-instructions" class="ios-instructions hidden">
    <ol>
      <li>Tap the share button <span style="font-size: 1.2em;">‚éô</span> at the bottom of your screen</li>
      <li>Scroll down and tap "Add to Home Screen"</li>
      <li>Tap "Add" in the top right corner</li>
    </ol>
  </div>
  
  
</div>


<!-- Debug panel toggle -->
<div style="margin-top: 20px; text-align: center;">
  <button id="toggle-debug" style="background-color: #6c757d; width: auto; font-size: 12px; padding: 5px 10px;">Show Debug Panel</button>
</div>
</div>

<!-- Scanner Screen -->
<div id="scanner-screen" class="hidden">
<div class="app-header">
  <h1>TIGER CLAW TIMING</h1>
  <div id="checkpoint-display" style="font-weight: bold; font-size: 18px; margin: 10px 0;"></div>
  
  <!-- Checkpoint Stats -->
  <div id="checkpoint-stats" class="checkpoint-stats">
    <div id="stats-text">Loading checkpoint stats...</div>
    <div class="progress-bar">
      <div id="progress-bar-fill" class="progress-bar-fill" style="width: 0%"></div>
    </div>
    <div class="stats-numbers">
      <span id="scanned-count">0 scanned</span>
      <span id="remaining-count">0 remaining</span>
    </div>
    <button id="refresh-stats" class="refresh-stats">Refresh Stats</button>
    <span id="stats-refreshing" class="stats-refreshing hidden"></span>
  </div>
  
  <!-- Connection status and refresh button -->
  <div class="connection-container">
    <div id="connection-status" class="connection-status">
      <span id="status-icon" class="status-icon">‚óè</span>
      <span id="status-text">CHECKING CONNECTION...</span>
    </div>
    <button id="refresh-button">Refresh Connection</button>
  </div>
</div>

<button id="scan-button" class="scan-button">START SCANNING</button>

<!-- HTML5QrCode scanner container -->
<div id="scanner-container" class="scanner-container hidden">
  <div id="qr-reader"></div>
  <div class="targeting-overlay"></div>
  <div id="flash-overlay" class="flash-overlay"></div>
  <div id="camera-loading" class="camera-loading">
    <div class="spinner"></div>
    <div>Starting camera...</div>
  </div>
  <div class="camera-instructions">Align QR code within the target</div>
</div>

<!-- Native camera fallback -->
<div id="native-camera-container" class="hidden">
  <video id="native-camera-video" autoplay playsinline></video>
  <canvas id="native-camera-canvas"></canvas>
  <div class="camera-instructions">Align QR code within the target</div>
</div>

<div id="message" class="success-message hidden"></div>

<div class="form-group manual-entry-section" style="margin-top: 20px;">
  <h2>Manual Entry</h2>
  <div class="form-group">
    <label for="bib-input">Bib Number (required)</label>
    <input type="tel" id="bib-input" inputmode="numeric" pattern="[0-9]*" placeholder="Enter bib number">
  </div>
  
  <button id="manual-submit-button">SUBMIT</button>
</div>

<div id="pending-uploads" class="pending-uploads hidden"></div>

<div id="recent-scans" class="recent-scans">
  <h3>Recent Scans</h3>
  <div id="scans-list"></div>
</div>

<button id="logout-button" style="background-color: #6c757d; margin-top: 20px;">Logout</button>

<!-- Debug panel (hidden by default) -->
<div id="debug-panel" class="debug-panel hidden">
  <h4>Debug Info</h4>
  <pre id="debug-info"></pre>
  <button id="force-upload" style="background-color: #6c757d; margin-top: 10px; font-size: 12px;">Force Upload Pending Scans</button>
  <button id="clear-data" style="background-color: #dc3545; margin-top: 10px; font-size: 12px;">Clear All Data</button>
  <button id="refresh-runners" style="background-color: #007bff; margin-top: 10px; font-size: 12px;">Refresh Runner Data</button>
</div>
</div>

<!-- Include the HTML5 QR Code Scanner library directly in the HTML -->
<script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

<script>
// Main application code
document.addEventListener('DOMContentLoaded', function() {
// DOM Elements
const loadingScreen = document.getElementById('loading-screen');
const loadingError = document.getElementById('loading-error');
const retryLoadingBtn = document.getElementById('retry-loading');
const loginScreen = document.getElementById('login-screen');
const scannerScreen = document.getElementById('scanner-screen');
const checkpointSelect = document.getElementById('checkpoint-select');
const passwordInput = document.getElementById('password-input');
const loginError = document.getElementById('login-error');
const loginForm = document.getElementById('login-form');
const checkpointDisplay = document.getElementById('checkpoint-display');
const scanButton = document.getElementById('scan-button');
const scannerContainer = document.getElementById('scanner-container');
const nativeCameraContainer = document.getElementById('native-camera-container');
const nativeCameraVideo = document.getElementById('native-camera-video');
const nativeCameraCanvas = document.getElementById('native-camera-canvas');
const flashOverlay = document.getElementById('flash-overlay');
const cameraLoading = document.getElementById('camera-loading');
const messageDisplay = document.getElementById('message');
const bibInput = document.getElementById('bib-input');
const manualSubmitButton = document.getElementById('manual-submit-button');
const logoutButton = document.getElementById('logout-button');
const connectionStatus = document.getElementById('connection-status');
const statusIcon = document.getElementById('status-icon');
const statusText = document.getElementById('status-text');
const pendingUploadsContainer = document.getElementById('pending-uploads');
const scansList = document.getElementById('scans-list');
const debugPanel = document.getElementById('debug-panel');
const debugInfo = document.getElementById('debug-info');
const toggleDebugBtn = document.getElementById('toggle-debug');
const forceUploadBtn = document.getElementById('force-upload');
const clearDataBtn = document.getElementById('clear-data');
const refreshButton = document.getElementById('refresh-button');
const refreshRunnersBtn = document.getElementById('refresh-runners');
const offlineBanner = document.getElementById('offline-banner');
const installPrompt = document.getElementById('install-prompt');
const installBtn = document.getElementById('install-btn');

  // DOM elements for installation
const androidInstallBtn = document.getElementById("android-install-btn");
const iosInstallBtn = document.getElementById("ios-install-btn");
const iosInstructions = document.getElementById("ios-install-instructions");
const qrCodeContainer = document.getElementById("qr-code-container");
const persistentInstallBtn = document.createElement("button");

// Checkpoint stats elements
const checkpointStats = document.getElementById('checkpoint-stats');
const statsText = document.getElementById('stats-text');
const progressBarFill = document.getElementById('progress-bar-fill');
const scannedCount = document.getElementById('scanned-count');
const remainingCount = document.getElementById('remaining-count');
const refreshStatsBtn = document.getElementById('refresh-stats');
const statsRefreshing = document.getElementById('stats-refreshing');

// Application state
let deferredInstallPrompt = null; // Store the install prompt event
let isScanning = false;
let isOnline = navigator.onLine;
let html5QrCode = null;
let checkpoint = '';
let pendingUploads = [];
let runnersData = {}; // Will store all runners data
let recentScans = []; // Store recent scans for display
let lastUploadAttempt = 0; // Track last upload attempt time
let debugMode = false; // Debug mode flag
let useNativeCamera = false; // Whether to use native camera API as fallback
let nativeCameraStream = null; // Store the camera stream
let processedScans = {}; // Track processed scans to prevent duplicates
let scanTimestamps = {}; // Track timestamps of scans to ensure we only keep the most recent
let cameraStartTimeout = null; // Timeout for camera start
let isUploadingPendingScans = false; // Flag to prevent multiple simultaneous uploads
let uploadedScans = {}; // Track which scans have been uploaded to prevent duplicates
let runnerDataRefreshInterval = null; // Interval for refreshing runner data
let checkpointStatsRefreshInterval = null; // Interval for refreshing checkpoint stats
let alreadyScannedRunners = new Set(); // Track which runners have already been scanned at this checkpoint
let isLoadingRunnerData = false; // Flag to prevent multiple simultaneous data loads
let isRefreshingStats = false; // Flag to prevent multiple simultaneous stats refreshes
let lastDnfCheck = 0; // Track when we last checked for DNF updates
let periodicUploadInterval = null; // Interval for periodic upload attempts
let dataLoadTimeoutId = null; // Store the timeout ID for data loading
let dataLoadAttempted = false; // Flag to track if we've attempted to load data

// Constants
const CORRECT_PASSWORD = "threeloops";
const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzdjHT6H6gPpM-CcRPx-Ds0QzFjKesESOorlKgBw1PFFaLKpN17r8bd-toYogsgLnoA/exec";
const RUNNER_DATA_REFRESH_INTERVAL = 2 * 60 * 1000; // 2 minutes
const CHECKPOINT_STATS_REFRESH_INTERVAL = 30 * 1000; // 30 seconds
const DNF_CHECK_INTERVAL = 60 * 1000; // 1 minute
const PERIODIC_UPLOAD_INTERVAL = 30 * 1000; // 30 seconds
const RUNNERS_SHEET_ID = "19ysJEfg5dDTUe6q-JXngWbUAziGmrn0jGilGy8SkcYg"; // Your runners spreadsheet ID
const RESULTS_SHEET_ID = "1StRgcagtoZs6x-TRCQMAWiTIqXKq__6_Gvcj8ysUz5c"; // Your results spreadsheet ID
const DATA_LOAD_TIMEOUT = 30000; // 30 seconds timeout for data loading

// Check for URL parameters (for QR code login)
function checkUrlParameters() {
  const urlParams = new URLSearchParams(window.location.search);
  const checkpointParam = urlParams.get('checkpoint');
  const passwordParam = urlParams.get('password');
  
  if (checkpointParam && passwordParam) {
    logDebug(`Found URL parameters: checkpoint=${checkpointParam}`);
    
    // Auto-fill the login form
    const checkpointOption = Array.from(checkpointSelect.options).find(
      option => option.value === checkpointParam
    );
    
    if (checkpointOption) {
      checkpointSelect.value = checkpointParam;
      passwordInput.value = passwordParam;
      
      // Auto login after a short delay
      setTimeout(() => {
        handleLogin();
      }, 500);
    }
  }
}

// Register service worker for offline support
function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('service-worker.js')
      .then(registration => {
        logDebug('Service Worker registered with scope: ' + registration.scope);
      })
      .catch(error => {
        logDebug('Service Worker registration failed: ' + error);
      });
  }
}

  // Set up persistent install button
function setupPersistentInstallButton() {
  persistentInstallBtn.className = "persistent-install-btn hidden";
  persistentInstallBtn.textContent = "üì± Install App";
  document.body.appendChild(persistentInstallBtn);
  
  // Add click handler
  persistentInstallBtn.addEventListener("click", triggerInstall);
}

// Detect iOS
function isIOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}

// Detect Android
function isAndroid() {
  return /Android/.test(navigator.userAgent);
}

// Generate QR code for the current page
function generateQRCode() {
  if (typeof QRCode !== "undefined") {
    try {
      // Clear previous QR code
      qrCodeContainer.innerHTML = "";

      // Generate new QR code with the current URL
      new QRCode(qrCodeContainer, {
        text: window.location.href,
        width: 150,
        height: 150,
        colorDark: "#28a745",
        colorLight: "#ffffff",
        correctLevel: QRCode.CorrectLevel.H,
      });
    } catch (e) {
      logDebug("Error generating QR code: " + e);
    }
  }
}

// Show appropriate install instructions based on platform
function showAppropriateInstallInstructions() {
  if (isIOS()) {
    if (iosInstallBtn) {
      iosInstallBtn.addEventListener("click", () => {
        iosInstructions.classList.toggle("hidden");
      });
    }
  } else {
    // For Android and other platforms, use the install prompt
    if (androidInstallBtn) {
      androidInstallBtn.addEventListener("click", triggerInstall);
    }
  }

  // Generate QR code for easy sharing
  generateQRCode();
}

// Function to trigger installation
function triggerInstall() {
  if (deferredInstallPrompt) {
    // Show the install prompt
    deferredInstallPrompt.prompt();

    // Wait for the user to respond to the prompt
    deferredInstallPrompt.userChoice.then((choiceResult) => {
      if (choiceResult.outcome === "accepted") {
        logDebug("User accepted the install prompt");
        // Hide install buttons
        installPrompt.classList.add("hidden");
        persistentInstallBtn.classList.add("hidden");
      } else {
        logDebug("User dismissed the install prompt");
      }
      deferredInstallPrompt = null;
    });
  } else {
    showMessage("App installation not available or already installed", true);
  }
}
  
// Enhanced beforeinstallprompt event handler
window.addEventListener("beforeinstallprompt", (e) => {
  // Prevent Chrome 67 and earlier from automatically showing the prompt
  e.preventDefault();

  // Stash the event so it can be triggered later
  deferredInstallPrompt = e;

  // Show install buttons (but not on iOS)
  if (!isIOS()) {
    installPrompt.classList.remove("hidden");
    persistentInstallBtn.classList.remove("hidden");
    logDebug("Install prompt detected and saved");
  }
});

// Check if app is already installed
window.addEventListener("appinstalled", (evt) => {
  logDebug("App was installed");
  // Hide install buttons
  installPrompt.classList.add("hidden");
  persistentInstallBtn.classList.add("hidden");
});

// Install button click handler
installBtn.addEventListener('click', () => {
  if (deferredInstallPrompt) {
    // Show the install prompt
    deferredInstallPrompt.prompt();
    
    // Wait for the user to respond to the prompt
    deferredInstallPrompt.userChoice.then((choiceResult) => {
      if (choiceResult.outcome === 'accepted') {
        logDebug('User accepted the install prompt');
        installPrompt.classList.add('hidden');
      } else {
        logDebug('User dismissed the install prompt');
      }
      deferredInstallPrompt = null;
    });
  }
});

// Retry loading button
retryLoadingBtn.addEventListener('click', function() {
  loadingError.classList.add('hidden');
  fetchRunnerData(true);
});

// Handle login form submission
loginForm.addEventListener('submit', function(event) {
  event.preventDefault();
  handleLogin();
});

// Handle login
function handleLogin() {
  const selectedCheckpoint = checkpointSelect.value;
  const password = passwordInput.value;
  
  if (!selectedCheckpoint) {
    loginError.textContent = 'Please select a checkpoint';
    loginError.classList.remove('hidden');
    return;
  }
  
  if (password !== CORRECT_PASSWORD) {
    loginError.textContent = 'Incorrect password';
    loginError.classList.remove('hidden');
    return;
  }
  
  // Clear old session data
  clearSessionData();
  
  // Save checkpoint and show scanner screen
  checkpoint = selectedCheckpoint;
  localStorage.setItem('tigerClawCheckpoint', checkpoint);
  showScannerScreen();
  
  // Fetch already scanned runners at this checkpoint
  fetchAlreadyScannedRunners();
  
  // Fetch fresh checkpoint stats
  fetchCheckpointStats(true);
  
  // Start periodic upload attempts
  startPeriodicUploadAttempts();
}

// Start periodic upload attempts
function startPeriodicUploadAttempts() {
  // Clear any existing interval
  if (periodicUploadInterval) {
    clearInterval(periodicUploadInterval);
  }
  
  // Set up new interval
  periodicUploadInterval = setInterval(() => {
    if (isOnline && pendingUploads.length > 0) {
      logDebug('Periodic upload attempt');
      uploadPendingScans();
    }
  }, PERIODIC_UPLOAD_INTERVAL);
}

// Clear session data when logging in
function clearSessionData() {
  // Clear recent scans
  recentScans = [];
  localStorage.removeItem('recentScans');
  
  // Clear processed scans tracking
  processedScans = {};
  localStorage.removeItem('processedScans');
  
  // Clear scan timestamps
  scanTimestamps = {};
  localStorage.removeItem('scanTimestamps');
  
  // Clear already scanned runners
  alreadyScannedRunners = new Set();
  
  // Update UI
  updateRecentScansUI();
  
  logDebug('Session data cleared for new login');
}

// Fetch already scanned runners at this checkpoint
function fetchAlreadyScannedRunners() {
  if (!checkpoint || !isOnline) return;
  
  logDebug(`Fetching already scanned runners at checkpoint: ${checkpoint}`);
    return;
  
  logDebug(`Fetching already scanned runners at checkpoint: ${checkpoint}`);
  
  // Use fetch API to get checkpoint stats with no-cors mode
  fetch(`${APPS_SCRIPT_URL}?action=getCheckpointStats&checkpoint=${encodeURIComponent(checkpoint)}`, {
    method: 'GET',
    mode: 'no-cors', // Use no-cors to avoid CORS errors
    cache: 'no-cache'
  })
  .then(() => {
    // Since we can't read the response with no-cors, we'll use the spreadsheet API directly
    fetchCheckpointStatsFromSpreadsheet();
  })
  .catch(error => {
    logDebug('Error fetching already scanned runners: ' + error);
    // We'll rely on the checkpoint stats to update this information
    fetchCheckpointStatsFromSpreadsheet();
  });
}

// Fetch checkpoint stats directly from the spreadsheet
function fetchCheckpointStatsFromSpreadsheet() {
  if (!checkpoint || !isOnline) {
    // If offline, calculate stats locally
    const stats = calculateLocalCheckpointStats();
    updateCheckpointStatsUI(stats);
    statsRefreshing.classList.add('hidden');
    isRefreshingStats = false;
    return;
  }
  
  logDebug(`Fetching checkpoint stats from spreadsheet for: ${checkpoint}`);
  
  // Add a cache-busting parameter to ensure we get fresh data
  const cacheBuster = new Date().getTime();
  
  // IMPORTANT: Clear the existing set of scanned runners before fetching new data
  // This ensures deleted entries are properly reflected
  alreadyScannedRunners = new Set();
  
  // Fetch directly from the results spreadsheet using the Google Visualization API
  const spreadsheetUrl = `https://docs.google.com/spreadsheets/d/${RESULTS_SHEET_ID}/gviz/tq?tqx=out:json&sheet=Sheet1&cacheBuster=${cacheBuster}`;
  
  fetch(spreadsheetUrl)
    .then(response => response.text())
    .then(text => {
      // The response is not pure JSON, it's wrapped in a callback
      // We need to extract the JSON part
      const jsonStart = text.indexOf('{');
      const jsonEnd = text.lastIndexOf('}') + 1;
      const jsonString = text.substring(jsonStart, jsonEnd);
      return JSON.parse(jsonString);
    })
    .then(data => {
      if (data && data.table && data.table.rows) {
        const rows = data.table.rows;
        const headers = data.table.cols.map(col => col.label);
        
        // Find column indices
        const bibIndex = headers.findIndex(h => h.toLowerCase().includes('bib'));
        const checkpointIndex = headers.findIndex(h => h.toLowerCase().includes('checkpoint'));
        
        if (bibIndex === -1 || checkpointIndex === -1) {
          throw new Error('Could not find required columns in spreadsheet');
        }
        
        // Process each row to find scans for this checkpoint
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i].c;
          if (row && row[bibIndex] && row[bibIndex].v && row[checkpointIndex] && row[checkpointIndex].v) {
            const bib = row[bibIndex].v.toString();
            const scanCheckpoint = row[checkpointIndex].v.toString();
            
            if (scanCheckpoint === checkpoint) {
              alreadyScannedRunners.add(bib);
            }
          }
        }
        
        logDebug(`Loaded ${alreadyScannedRunners.size} already scanned runners from spreadsheet`);
        
        // Reset processed scans for runners that no longer have entries
        // This allows them to be scanned again if their entry was deleted
        resetProcessedScansForDeletedEntries();
        
        // Now fetch runner data to get accurate total count and DNF status
        return fetchRunnerDataForStats();
      } else {
        throw new Error('Invalid spreadsheet data format');
      }
    })
    .then(() => {
      // Calculate and update stats with the fresh data
      const stats = calculateLocalCheckpointStats();
      updateCheckpointStatsUI(stats);
    })
    .catch(error => {
      logDebug('Error fetching checkpoint stats from spreadsheet: ' + error);
      // Calculate stats locally as fallback
      const stats = calculateLocalCheckpointStats();
      updateCheckpointStatsUI(stats);
    })
    .finally(() => {
      // Hide the refreshing indicator
      statsRefreshing.classList.add('hidden');
      isRefreshingStats = false;
    });
}

// Fetch runner data specifically for stats updates
function fetchRunnerDataForStats() {
  return new Promise((resolve, reject) => {
    if (!isOnline) {
      resolve(); // Use existing data if offline
      return;
    }
    
    logDebug('Fetching runner data for stats update');
    
    // Add a cache-busting parameter to ensure we get fresh data
    const cacheBuster = new Date().getTime();
    
    // Fetch directly from the spreadsheet using the Google Visualization API
    const spreadsheetUrl = `https://docs.google.com/spreadsheets/d/${RUNNERS_SHEET_ID}/gviz/tq?tqx=out:json&cacheBuster=${cacheBuster}`;
    
    fetch(spreadsheetUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.text();
      })
      .then(text => {
        try {
          // The response is not pure JSON, it's wrapped in a callback
          // We need to extract the JSON part
          const jsonStart = text.indexOf('{');
          const jsonEnd = text.lastIndexOf('}') + 1;
          if (jsonStart === -1 || jsonEnd === 0) {
            throw new Error('Invalid response format - could not find JSON data');
          }
          const jsonString = text.substring(jsonStart, jsonEnd);
          return JSON.parse(jsonString);
        } catch (e) {
          throw new Error(`Error parsing spreadsheet response: ${e.message}`);
        }
      })
      .then(data => {
        if (data && data.table && data.table.rows) {
          const runnerMap = {};
          const rows = data.table.rows;
          const headers = data.table.cols.map(col => col.label);
          
          // Find column indices
          const bibIndex = headers.findIndex(h => h && h.toLowerCase().includes('bib'));
          const nameIndex = headers.findIndex(h => h && h.toLowerCase().includes('name'));
          const statusIndex = headers.findIndex(h => h === 'DNF' || (h && h.toLowerCase().includes('status')));
          
          if (bibIndex === -1 || nameIndex === -1) {
            throw new Error('Could not find required columns in spreadsheet');
          }
          
          for (let i = 0; i < rows.length; i++) {
            const row = rows[i].c;
            if (row && row[bibIndex] && row[bibIndex].v) {
              const bib = row[bibIndex].v.toString();
              const name = row[nameIndex] && row[nameIndex].v ? row[nameIndex].v.toString() : 'Unknown';
              let dnf = false;
              
              // Check for DNF in status column
              if (statusIndex !== -1 && row[statusIndex] && row[statusIndex].v) {
                const status = row[statusIndex].v.toString().toUpperCase();
                dnf = (status === 'DNF' || status === 'DNS' || status === 'TRUE');
              }
              
              runnerMap[bib] = {
                name: name,
                dnf: dnf
              };
            }
          }
          
          if (Object.keys(runnerMap).length === 0) {
            throw new Error('No runner data found in spreadsheet');
          }
          
          // Update the last DNF check timestamp
          lastDnfCheck = Date.now();
          
          runnersData = runnerMap;
          localStorage.setItem('runnersData', JSON.stringify(runnersData));
          logDebug(`Updated ${Object.keys(runnersData).length} runners for stats calculation`);
          
          resolve();
        } else {
          throw new Error('Invalid spreadsheet data format');
        }
      })
      .catch(error => {
        logDebug('Error fetching runner data for stats: ' + error);
        // Continue with existing data
        resolve();
      });
  });
}

// Set up periodic refresh of checkpoint stats
function setupCheckpointStatsRefresh() {
  // Clear any existing interval
  if (checkpointStatsRefreshInterval) {
    clearInterval(checkpointStatsRefreshInterval);
  }
  
  // Set up new interval - refresh every 5 seconds
  checkpointStatsRefreshInterval = setInterval(() => {
    if (isOnline && checkpoint) {
      logDebug('Periodic checkpoint stats refresh');
      fetchCheckpointStatsFromSpreadsheet();
    }
  }, 5000); // Changed from 30 seconds to 5 seconds
}

// Reset processed scans for runners that no longer have entries in the results spreadsheet
function resetProcessedScansForDeletedEntries() {
  // Create a list of keys to remove
  const keysToRemove = [];
  
  // Check each processed scan
  for (const key in processedScans) {
    // Keys are in the format "bib-checkpoint"
    const parts = key.split('-');
    if (parts.length === 2) {
      const bib = parts[0];
      const scanCheckpoint = parts[1];
      
      // If this is for our current checkpoint and the runner is not in alreadyScannedRunners,
      // then their entry was likely deleted from the spreadsheet
      if (scanCheckpoint === checkpoint && !alreadyScannedRunners.has(bib)) {
        keysToRemove.push(key);
      }
    }
  }
  
  // Remove the keys
  if (keysToRemove.length > 0) {
    logDebug(`Resetting ${keysToRemove.length} processed scans for deleted entries`);
    
    keysToRemove.forEach(key => {
      delete processedScans[key];
      delete scanTimestamps[key];
      logDebug(`Reset processed scan for ${key} - entry was deleted from spreadsheet`);
    });
    
    // Save the updated processed scans
    saveProcessedScans();
    saveScanTimestamps();
  }
}

// Refresh checkpoint stats button
refreshStatsBtn.addEventListener('click', function() {
  if (isRefreshingStats) return; // Prevent multiple simultaneous refreshes
  
  logDebug('Manual checkpoint stats refresh requested');
  isRefreshingStats = true;
  statsRefreshing.classList.remove('hidden');
  
  // Clear the existing set of scanned runners to force a complete refresh
  alreadyScannedRunners = new Set();
  
  // Force a complete refresh of both runner data and checkpoint stats
  fetchRunnerDataForStats()
    .then(() => {
      // Then fetch checkpoint stats with a forced refresh
      fetchCheckpointStatsFromSpreadsheet();
    })
    .catch(() => {
      // If there's an error, still try to fetch checkpoint stats
      fetchCheckpointStatsFromSpreadsheet();
    });
});

// Log to debug panel
function logDebug(message) {
  const timestamp = new Date().toLocaleTimeString();
  if (debugInfo) {
    debugInfo.textContent = `[${timestamp}] ${message}\n` + debugInfo.textContent;
  }
  console.log(message);
}

// Toggle debug panel
toggleDebugBtn.addEventListener('click', function() {
  debugMode = !debugMode;
  if (debugMode) {
    debugPanel.classList.remove('hidden');
    toggleDebugBtn.textContent = 'Hide Debug Panel';
  } else {
    debugPanel.classList.add('hidden');
    toggleDebugBtn.textContent = 'Show Debug Panel';
  }
});

// Force upload pending scans
forceUploadBtn.addEventListener('click', function() {
  logDebug('Manually forcing upload of pending scans');
  uploadPendingScans(true);
});

// Refresh runner data manually
refreshRunnersBtn.addEventListener('click', function() {
  logDebug('Manually refreshing runner data');
  fetchRunnerData(true);
});

// Clear all data
clearDataBtn.addEventListener('click', function() {
  if (confirm('Are you sure you want to clear all data? This will delete all stored runner data and scans.')) {
    clearAllData();
  }
});

// Refresh connection button
refreshButton.addEventListener('click', function() {
  logDebug('Manual connection refresh requested');
  
  // Check connection
  const currentOnlineStatus = navigator.onLine;
  logDebug(`Current connection status: ${currentOnlineStatus ? 'online' : 'offline'}`);
  
  if (currentOnlineStatus) {
    showMessage('Checking for pending uploads...');
    uploadPendingScans(true);
    
    // Also refresh runner data
    fetchRunnerData(true);
    
    // Fetch already scanned runners
    fetchAlreadyScannedRunners();
  } else {
    showMessage('No internet connection available', true);
  }
});

// Refresh checkpoint stats button
refreshStatsBtn.addEventListener('click', function() {
  if (isRefreshingStats) return; // Prevent multiple simultaneous refreshes
  
  logDebug('Manual checkpoint stats refresh requested');
  isRefreshingStats = true;
  statsRefreshing.classList.remove('hidden');
  
  // Clear the existing set of scanned runners to force a complete refresh
  alreadyScannedRunners = new Set();
  
  // Force a complete refresh of both runner data and checkpoint stats
  fetchRunnerDataForStats()
    .then(() => {
      // Then fetch checkpoint stats with a forced refresh
      fetchCheckpointStatsFromSpreadsheet();
    })
    .catch(() => {
      // If there's an error, still try to fetch checkpoint stats
      fetchCheckpointStatsFromSpreadsheet();
    });
});

// Clear all data from localStorage
function clearAllData() {
  try {
    localStorage.removeItem('pendingUploads');
    localStorage.removeItem('recentScans');
    localStorage.removeItem('runnersData');
    localStorage.removeItem('processedScans');
    localStorage.removeItem('scanTimestamps');
    localStorage.removeItem('uploadedScans');
    
    pendingUploads = [];
    recentScans = [];
    runnersData = {};
    processedScans = {};
    scanTimestamps = {};
    uploadedScans = {};
    alreadyScannedRunners = new Set();
    
    updatePendingUploadsUI();
    updateRecentScansUI();
    
    logDebug('All data cleared successfully');
    showMessage('All data cleared successfully');
    
    // Fetch fresh runner data
    fetchRunnerData(true);
    
    // Fetch already scanned runners
    fetchAlreadyScannedRunners();
  } catch (error) {
    logDebug('Error clearing data: ' + error);
    showMessage('Error clearing data', true);
  }
}

// Initialize the application
function init() {

  // Set up persistent install button
setupPersistentInstallButton();

// Set up installation instructions
showAppropriateInstallInstructions();

  
  // Register service worker
  registerServiceWorker();
  
  // Check for URL parameters (for QR code login)
  checkUrlParameters();
  
  // Load data from localStorage
  loadPendingScans();
  loadProcessedScans();
  loadScanTimestamps();
  loadUploadedScans();
  
  // Set initial online status
  isOnline = navigator.onLine;
  updateOfflineBanner();
  
  // Set up online/offline event listeners
  window.addEventListener('online', handleOnlineStatusChange);
  window.addEventListener('offline', handleOnlineStatusChange);
  
  // Check if we already have runner data in localStorage
  try {
    const storedData = localStorage.getItem('runnersData');
    if (storedData) {
      const parsedData = JSON.parse(storedData);
      if (parsedData && Object.keys(parsedData).length > 0) {
        // We have data, use it immediately
        runnersData = parsedData;
        logDebug(`Loaded ${Object.keys(runnersData).length} runners from localStorage at init`);
        
        // Check for pending uploads that need to be processed
        if (pendingUploads.length > 0) {
          logDebug(`Found ${pendingUploads.length} pending uploads at startup`);
          updatePendingUploadsUI();
        }
        
        loadingScreen.classList.add('hidden');
        checkLoginStatus();
        
        // Still fetch fresh data in the background
        setTimeout(() => {
          fetchRunnerData(true);
        }, 1000);
        
        return;
      }
    }
  } catch (error) {
    logDebug('Error loading runners data from localStorage at init: ' + error);
  }
  
  // If we don't have data, fetch it
  fetchRunnerData(true);
  
  // Check if we have pending uploads and we're online
  if (isOnline && pendingUploads.length > 0) {
    logDebug(`Found ${pendingUploads.length} pending uploads at startup - attempting to upload`);
    setTimeout(() => {
      uploadPendingScans(true);
    }, 3000);
  }
}

// Update offline banner
function updateOfflineBanner() {
  if (!isOnline) {
    offlineBanner.classList.remove('hidden');
  } else {
    offlineBanner.classList.add('hidden');
  }
}

// Load uploaded scans from localStorage
function loadUploadedScans() {
  try {
    const storedUploadedScans = localStorage.getItem('uploadedScans');
    if (storedUploadedScans) {
      uploadedScans = JSON.parse(storedUploadedScans);
      logDebug(`Loaded uploaded scans tracking data from localStorage`);
    }
  } catch (error) {
    logDebug('Error loading uploaded scans: ' + error);
    uploadedScans = {};
  }
}

// Save uploaded scans to localStorage
function saveUploadedScans() {
  try {
    localStorage.setItem('uploadedScans', JSON.stringify(uploadedScans));
  } catch (error) {
    logDebug('Error saving uploaded scans: ' + error);
  }
}

// Load processed scans from localStorage
function loadProcessedScans() {
  try {
    const storedProcessedScans = localStorage.getItem('processedScans');
    if (storedProcessedScans) {
      processedScans = JSON.parse(storedProcessedScans);
      logDebug(`Loaded processed scans tracking data from localStorage`);
    }
  } catch (error) {
    logDebug('Error loading processed scans: ' + error);
    processedScans = {};
  }
}

// Load scan timestamps from localStorage
function loadScanTimestamps() {
  try {
    const storedTimestamps = localStorage.getItem('scanTimestamps');
    if (storedTimestamps) {
      scanTimestamps = JSON.parse(storedTimestamps);
      logDebug(`Loaded scan timestamps from localStorage`);
    }
  } catch (error) {
    logDebug('Error loading scan timestamps: ' + error);
    scanTimestamps = {};
  }
}

// Save processed scans to localStorage
function saveProcessedScans() {
  try {
    localStorage.setItem('processedScans', JSON.stringify(processedScans));
  } catch (error) {
    logDebug('Error saving processed scans: ' + error);
  }
}

// Save scan timestamps to localStorage
function saveScanTimestamps() {
  try {
    localStorage.setItem('scanTimestamps', JSON.stringify(scanTimestamps));
  } catch (error) {
    logDebug('Error saving scan timestamps: ' + error);
  }
}

// Handle online/offline status changes
function handleOnlineStatusChange() {
  const wasOnline = isOnline;
  isOnline = navigator.onLine;
  
  logDebug(`Connection status changed: ${wasOnline ? 'online' : 'offline'} -> ${isOnline ? 'online' : 'offline'}`);
  updateConnectionStatus();
  updateOfflineBanner();
  
  // If we're back online and have offline entries, try to sync them
  if (isOnline && !wasOnline && pendingUploads.length > 0) {
    logDebug('Connection restored - attempting to upload pending scans');
    // Wait a moment for the connection to stabilize
    setTimeout(() => {
      uploadPendingScans(true);
    }, 2000);
  }
  
  // If we're back online, refresh runner data
  if (isOnline && !wasOnline) {
    fetchRunnerData(true);
    fetchCheckpointStatsFromSpreadsheet();
  }
}

// Load pending scans from localStorage
function loadPendingScans() {
  try {
    const storedUploads = localStorage.getItem('pendingUploads');
    if (storedUploads) {
      pendingUploads = JSON.parse(storedUploads);
      logDebug(`Loaded ${pendingUploads.length} pending scans from localStorage`);
      updatePendingUploadsUI();
    }
  } catch (error) {
    logDebug('Error loading pending scans: ' + error);
    pendingUploads = [];
  }
}

// Load recent scans from localStorage - only load if we're already logged in
function loadRecentScans() {
  if (!checkpoint) return; // Don't load if not logged in
  
  try {
    const storedScans = localStorage.getItem('recentScans');
    if (storedScans) {
      recentScans = JSON.parse(storedScans);
      logDebug(`Loaded ${recentScans.length} recent scans from localStorage`);
      updateRecentScansUI();
    }
  } catch (error) {
    logDebug('Error loading recent scans: ' + error);
    recentScans = [];
  }
}

// Fetch runner data from Apps Script
function fetchRunnerData(forceRefresh = false) {
  if (isLoadingRunnerData) return; // Prevent multiple simultaneous loads
  isLoadingRunnerData = true;
  
  // Show loading screen if we don't have any runner data yet
  if (Object.keys(runnersData).length === 0) {
    loadingScreen.classList.remove('hidden');
    loadingError.classList.add('hidden');
  }
  
  logDebug('Fetching runner data from Google Apps Script...');
  
  // Try to load from localStorage first if not forcing refresh
  if (!forceRefresh) {
    try {
      const storedData = localStorage.getItem('runnersData');
      if (storedData) {
        const parsedData = JSON.parse(storedData);
        if (parsedData && Object.keys(parsedData).length > 0) {
          runnersData = parsedData;
          logDebug(`Loaded ${Object.keys(runnersData).length} runners from localStorage`);
          loadingScreen.classList.add('hidden');
          isLoadingRunnerData = false;
          checkLoginStatus();
          
          // Set up periodic refresh of runner data
          setupRunnerDataRefresh();
          
          // Fetch checkpoint stats if we're logged in
          if (checkpoint) {
            fetchCheckpointStatsFromSpreadsheet();
          }
          
          return;
        }
      }
    } catch (error) {
      logDebug('Error loading runners data from localStorage: ' + error);
    }
  }
  
  // Set a timeout to handle cases where the fetch never completes
  const timeoutId = setTimeout(() => {
    if (isLoadingRunnerData) {
      logDebug('Runner data fetch timed out');
      isLoadingRunnerData = false;
      loadingError.classList.remove('hidden');
      
      // Create sample data as fallback when timeout occurs
      const sampleRunners = {
        "101": { name: "Gus Newberry", dnf: false },
        "102": { name: "Jane Smith", dnf: false },
        "103": { name: "Bob Johnson", dnf: false },
        "104": { name: "Alice Williams", dnf: false },
        "105": { name: "Charlie Brown", dnf: false }
      };
      
      runnersData = sampleRunners;
      localStorage.setItem('runnersData', JSON.stringify(runnersData));
      logDebug(`Created sample runner data as fallback after timeout`);
      
      // Hide loading screen and proceed with sample data
      loadingScreen.classList.add('hidden');
      checkLoginStatus();
    }
  }, DATA_LOAD_TIMEOUT);
  
  // First try direct fetch from spreadsheet as primary method
  fetchRunnerDataFromSpreadsheet(forceRefresh)
    .then(() => {
      clearTimeout(timeoutId);
      loadingScreen.classList.add('hidden');
      isLoadingRunnerData = false;
      checkLoginStatus();
      
      // Set up periodic refresh of runner data
      setupRunnerDataRefresh();
      
      // Fetch checkpoint stats if we're logged in
      if (checkpoint) {
        fetchCheckpointStatsFromSpreadsheet();
      }
    })
    .catch(error => {
      logDebug('Error fetching runner data from spreadsheet: ' + error);
      
      // Try Apps Script as fallback
      fetch(`${APPS_SCRIPT_URL}?action=getRunnerData`, {
        method: 'GET',
        mode: 'no-cors',
        cache: 'no-cache'
      })
      .then(() => {
        // Since we can't read the response with no-cors, we'll use sample data
        clearTimeout(timeoutId);
        
        // Create sample data as fallback
        const sampleRunners = {
          "101": { name: "Gus Newberry", dnf: false },
          "102": { name: "Jane Smith", dnf: false },
          "103": { name: "Bob Johnson", dnf: false },
          "104": { name: "Alice Williams", dnf: false },
          "105": { name: "Charlie Brown", dnf: false }
        };
        
        runnersData = sampleRunners;
        localStorage.setItem('runnersData', JSON.stringify(runnersData));
        logDebug(`Created sample runner data as fallback after Apps Script attempt`);
        
        // Hide loading screen and proceed with sample data
        loadingScreen.classList.add('hidden');
        isLoadingRunnerData = false;
        checkLoginStatus();
        
        // Set up periodic refresh of runner data
        setupRunnerDataRefresh();
      })
      .catch(error => {
        clearTimeout(timeoutId);
        logDebug('All runner data fetch methods failed: ' + error);
        
        // Show error and let user proceed with sample data
        loadingError.classList.remove('hidden');
        
        // Create sample data as last resort
        const sampleRunners = {
          "101": { name: "Gus Newberry", dnf: false },
          "102": { name: "Jane Smith", dnf: false },
          "103": { name: "Bob Johnson", dnf: false },
          "104": { name: "Alice Williams", dnf: false },
          "105": { name: "Charlie Brown", dnf: false }
        };
        
        runnersData = sampleRunners;
        localStorage.setItem('runnersData', JSON.stringify(runnersData));
        logDebug(`Created sample runner data as final fallback`);
        
        // We still need to hide the loading screen and proceed
        isLoadingRunnerData = false;
        loadingScreen.classList.add('hidden');
        checkLoginStatus();
      });
    });
}

// Fetch runner data directly from the spreadsheet
function fetchRunnerDataFromSpreadsheet(forceRefresh = false) {
  return new Promise((resolve, reject) => {
    logDebug('Fetching runner data directly from spreadsheet');
    
    // Add a cache-busting parameter to ensure we get fresh data
    const cacheBuster = new Date().getTime();
    
    // Fetch directly from the spreadsheet using the Google Visualization API
    const spreadsheetUrl = `https://docs.google.com/spreadsheets/d/${RUNNERS_SHEET_ID}/gviz/tq?tqx=out:json&cacheBuster=${cacheBuster}`;
    
    fetch(spreadsheetUrl)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.text();
      })
      .then(text => {
        try {
          // The response is not pure JSON, it's wrapped in a callback
          // We need to extract the JSON part
          const jsonStart = text.indexOf('{');
          const jsonEnd = text.lastIndexOf('}') + 1;
          if (jsonStart === -1 || jsonEnd === 0) {
            throw new Error('Invalid response format - could not find JSON data');
          }
          const jsonString = text.substring(jsonStart, jsonEnd);
          return JSON.parse(jsonString);
        } catch (e) {
          throw new Error(`Error parsing spreadsheet response: ${e.message}`);
        }
      })
      .then(data => {
        if (data && data.table && data.table.rows) {
          const runnerMap = {};
          const rows = data.table.rows;
          const headers = data.table.cols.map(col => col.label);
          
          // Find column indices
          const bibIndex = headers.findIndex(h => h && h.toLowerCase().includes('bib'));
          const nameIndex = headers.findIndex(h => h && h.toLowerCase().includes('name'));
          const statusIndex = headers.findIndex(h => h === 'DNF' || (h && h.toLowerCase().includes('status')));
          
          if (bibIndex === -1 || nameIndex === -1) {
            throw new Error('Could not find required columns in spreadsheet');
          }
          
          for (let i = 0; i < rows.length; i++) {
            const row = rows[i].c;
            if (row && row[bibIndex] && row[bibIndex].v) {
              const bib = row[bibIndex].v.toString();
              const name = row[nameIndex] && row[nameIndex].v ? row[nameIndex].v.toString() : 'Unknown';
              let dnf = false;
              
              // Check for DNF in status column
              if (statusIndex !== -1 && row[statusIndex] && row[statusIndex].v) {
                const status = row[statusIndex].v.toString().toUpperCase();
                dnf = (status === 'DNF' || status === 'DNS' || status === 'TRUE');
              }
              
              runnerMap[bib] = {
                name: name,
                dnf: dnf
              };
            }
          }
          
          if (Object.keys(runnerMap).length === 0) {
            throw new Error('No runner data found in spreadsheet');
          }
          
          // Update the last DNF check timestamp
          lastDnfCheck = Date.now();
          
          runnersData = runnerMap;
          localStorage.setItem('runnersData', JSON.stringify(runnersData));
          logDebug(`Loaded ${Object.keys(runnersData).length} runners directly from spreadsheet`);
          
          // Update recent scans UI to reflect any DNF changes
          updateRecentScansUI();
          
          resolve();
        } else {
          throw new Error('Invalid spreadsheet data format');
        }
      })
      .catch(error => {
        logDebug('Error fetching runner data from spreadsheet: ' + error);
        reject(error);
      });
  });
}

// Set up periodic refresh of runner data
function setupRunnerDataRefresh() {
  // Clear any existing interval
  if (runnerDataRefreshInterval) {
    clearInterval(runnerDataRefreshInterval);
  }
  
  // Set up new interval
  runnerDataRefreshInterval = setInterval(() => {
    if (isOnline) {
      logDebug('Periodic runner data refresh');
      fetchRunnerData(true);
    }
  }, RUNNER_DATA_REFRESH_INTERVAL);
}

// Fetch checkpoint stats
function fetchCheckpointStats(forceRefresh = false) {
  if (!checkpoint || !isOnline) return;
  
  if (forceRefresh) {
    // Show refreshing indicator
    statsRefreshing.classList.remove('hidden');
    isRefreshingStats = true;
  }
  
  logDebug(`Fetching stats for checkpoint: ${checkpoint}`);
  
  // Update UI to show loading
  statsText.textContent = 'Loading checkpoint stats...';
  
  // Fetch directly from spreadsheet
  fetchCheckpointStatsFromSpreadsheet();
}

// Calculate checkpoint stats locally based on our data
function calculateLocalCheckpointStats() {
  // Count total active runners (not DNF)
  let totalRunners = 0;
  for (const bib in runnersData) {
    if (!runnersData[bib].dnf) {
      totalRunners++;
    }
  }
  
  // Count scanned runners at this checkpoint
  const scannedBibs = new Set([...alreadyScannedRunners]);
  
  // Also check recent scans
  recentScans.forEach(scan => {
    if (scan.checkpoint === checkpoint) {
      scannedBibs.add(scan.bib);
    }
  });
  
  // Also check pending uploads
  pendingUploads.forEach(scan => {
    if (scan.checkpoint === checkpoint) {
      scannedBibs.add(scan.bib);
    }
  });
  
  // Filter out DNF runners from the scanned count
  const activeScannedBibs = Array.from(scannedBibs).filter(bib => {
    return runnersData[bib] && !runnersData[bib].dnf;
  });
  
  const scannedCount = activeScannedBibs.length;
  const remainingCount = totalRunners - scannedCount;
  
  return {
    checkpoint: checkpoint,
    totalRunners: totalRunners,
    scannedCount: scannedCount,
    remainingCount: remainingCount,
    scannedPercentage: totalRunners > 0 ? Math.round((scannedCount / totalRunners) * 100) : 0,
    scannedBibs: activeScannedBibs
  };
}

// Update checkpoint stats UI
function updateCheckpointStatsUI(stats) {
  statsText.textContent = `${stats.scannedCount} of ${stats.totalRunners} runners scanned (${stats.scannedPercentage}%)`;
  progressBarFill.style.width = `${stats.scannedPercentage}%`;
  scannedCount.textContent = `${stats.scannedCount} scanned`;
  remainingCount.textContent = `${stats.remainingCount} remaining`;
}

// Set up periodic refresh of checkpoint stats
function setupCheckpointStatsRefresh() {
  // Clear any existing interval
  if (checkpointStatsRefreshInterval) {
    clearInterval(checkpointStatsRefreshInterval);
  }
  
  // Set up new interval
  checkpointStatsRefreshInterval = setInterval(() => {
    if (isOnline && checkpoint) {
      logDebug('Periodic checkpoint stats refresh');
      fetchCheckpointStatsFromSpreadsheet();
    }
  }, 5000); // Changed from 30 seconds to 5 seconds
}

// Update recent scans UI
function updateRecentScansUI() {
  scansList.innerHTML = '';
  
  if (recentScans.length === 0) {
    scansList.innerHTML = '<p>No scans yet</p>';
    return;
  }
  
  recentScans.forEach(scan => {
    const scanTime = new Date(scan.timestamp).toLocaleTimeString();
    const scanItem = document.createElement('div');
    scanItem.className = 'scan-item';
    
    // Check if runner is marked as DNF
    const runnerInfo = runnersData[scan.bib];
    const isDnf = runnerInfo && runnerInfo.dnf;
    
    scanItem.innerHTML = `
      <div>
        <span class="scan-bib">#${scan.bib}</span> - ${scan.name}
        ${isDnf ? '<span class="dnf-indicator">DNF</span>' : ''}
      </div>
      <div class="scan-time">${scanTime}</div>
    `;
    scansList.appendChild(scanItem);
  });
}

// Update pending uploads UI
function updatePendingUploadsUI() {
  if (pendingUploads.length > 0) {
    pendingUploadsContainer.classList.remove('hidden');
    pendingUploadsContainer.textContent = `${pendingUploads.length} scan${pendingUploads.length > 1 ? 's' : ''} pending upload. Data will be uploaded automatically when connection is restored.`;
  } else {
    pendingUploadsContainer.classList.add('hidden');
    pendingUploadsContainer.textContent = '';
  }
  
  // Log the current state for debugging
  logDebug(`Pending uploads UI updated: ${pendingUploads.length} scans pending`);
}

// Update connection status UI
function updateConnectionStatusUI() {
  if (isOnline) {
    statusIcon.style.color = '#28a745';
    statusText.textContent = 'CONNECTED';
    statusText.classList.add('status-connected');
    statusText.classList.remove('status-disconnected');
  } else {
    statusIcon.style.color = '#dc3545';
    statusText.textContent = 'DISCONNECTED';
    statusText.classList.add('status-disconnected');
    statusText.classList.remove('status-connected');
  }
}

// Update connection status and check connectivity
function updateConnectionStatus() {
  // First check navigator.onLine
  isOnline = navigator.onLine;
  updateConnectionStatusUI();
  updateOfflineBanner();
  
  // If we're online and have pending uploads, try to upload them
  if (isOnline && pendingUploads.length > 0) {
    const now = Date.now();
    if (now - lastUploadAttempt > 5000) {
      lastUploadAttempt = now;
      uploadPendingScans();
    }
  }
}

// Check if user is already logged in
function checkLoginStatus() {
  const savedCheckpoint = localStorage.getItem('tigerClawCheckpoint');
  if (savedCheckpoint) {
    checkpoint = savedCheckpoint;
    showScannerScreen();
    
    // Load recent scans after login
    loadRecentScans();
    
    // Fetch already scanned runners
    fetchAlreadyScannedRunners();
    
    // Start periodic upload attempts
    startPeriodicUploadAttempts();
  } else {
    loginScreen.classList.remove('hidden');
  }
}

// Show scanner screen
function showScannerScreen() {
  loginScreen.classList.add('hidden');
  loadingScreen.classList.add('hidden');
  scannerScreen.classList.remove('hidden');
  checkpointDisplay.textContent = checkpoint;
  updateConnectionStatus();
  fetchCheckpointStats();
  setupCheckpointStatsRefresh();
}

// Show login screen
function showLoginScreen() {
  scannerScreen.classList.add('hidden');
  loadingScreen.classList.add('hidden');
  loginScreen.classList.remove('hidden');
  
  // Clear form
  checkpointSelect.value = '';
  passwordInput.value = '';
  loginError.classList.add('hidden');
}

// Handle logout
logoutButton.addEventListener('click', function() {
  // Stop scanner if running
  stopScanning();
  
  // Clear intervals
  if (runnerDataRefreshInterval) {
    clearInterval(runnerDataRefreshInterval);
    runnerDataRefreshInterval = null;
  }
  
  if (checkpointStatsRefreshInterval) {
    clearInterval(checkpointStatsRefreshInterval);
    checkpointStatsRefreshInterval = null;
  }
  
  if (periodicUploadInterval) {
    clearInterval(periodicUploadInterval);
    periodicUploadInterval = null;
  }
  
  localStorage.removeItem('tigerClawCheckpoint');
  checkpoint = '';
  showLoginScreen();
});

// Stop scanning (both HTML5QrCode and native camera)
function stopScanning() {
  if (isScanning) {
    // Clear any pending camera start timeout
    if (cameraStartTimeout) {
      clearTimeout(cameraStartTimeout);
      cameraStartTimeout = null;
    }
    
    if (html5QrCode) {
      try {
        html5QrCode.stop().catch(err => {
          logDebug("Error stopping HTML5QrCode scanner: " + err);
        });
        html5QrCode = null;
      } catch (e) {
        logDebug("Error stopping HTML5QrCode scanner: " + e);
      }
    }
    
    if (nativeCameraStream) {
      try {
        nativeCameraStream.getTracks().forEach(track => track.stop());
        nativeCameraStream = null;
      } catch (e) {
        logDebug("Error stopping native camera: " + e);
      }
    }
    
    isScanning = false;
    scannerContainer.classList.add('hidden');
    nativeCameraContainer.classList.add('hidden');
    scanButton.textContent = 'START SCANNING';
    scanButton.style.backgroundColor = '#28a745';
    
    // Remove scanner-active class from scanner screen
    scannerScreen.classList.remove('scanner-active');
  }
}

// Toggle scanner
scanButton.addEventListener('click', function() {
  if (isScanning) {
    stopScanning();
  } else {
    // Start scanning
    isScanning = true;
    scanButton.textContent = 'STOP SCANNING';
    scanButton.style.backgroundColor = '#dc3545';
    
    // Add scanner-active class from scanner screen
    scannerScreen.classList.add('scanner-active');
    
    // Start the scanner
    startScanner();
  }
});

// Start QR scanner with back camera
function startScanner() {
  try {
    // First, ensure any existing scanner is properly stopped
    if (html5QrCode) {
      try {
        html5QrCode.stop().then(() => {
          logDebug("Previous scanner stopped successfully");
        }).catch(err => {
          logDebug("Error stopping previous scanner: " + err);
        }).finally(() => {
          html5QrCode = null;
          initializeNewScanner();
        });
      } catch (e) {
        logDebug("Error stopping existing scanner: " + e);
        html5QrCode = null;
        initializeNewScanner();
      }
    } else {
      initializeNewScanner();
    }
  } catch (error) {
    logDebug("Error in startScanner: " + error);
    showMessage("Error initializing scanner. Please try manual entry.", true);
    stopScanning();
  }
}

// Separate function to initialize a new scanner
function initializeNewScanner() {
  // Clear any existing HTML in the qr-reader div
  const qrReaderElement = document.getElementById('qr-reader');
  if (qrReaderElement) {
    qrReaderElement.innerHTML = '';
  }
  
  // Show the scanner container with loading indicator
  scannerContainer.classList.remove('hidden');
  cameraLoading.classList.remove('hidden');
  nativeCameraContainer.classList.add('hidden');
  
  // Create a new instance of the QR scanner
  html5QrCode = new Html5Qrcode("qr-reader");
  
  // Simple configuration that works reliably
  const config = {
    fps: 10,
    qrbox: { width: 250, height: 250 },
    rememberLastUsedCamera: true,
    aspectRatio: 1.0
  };
  
  // Clear any existing timeout
  if (cameraStartTimeout) {
    clearTimeout(cameraStartTimeout);
  }
  
  // Set a timeout to detect if camera doesn't start
  cameraStartTimeout = setTimeout(() => {
    logDebug("Camera start timeout - trying fallback");
    if (html5QrCode) {
      try {
        html5QrCode.stop().catch(() => {});
      } catch (e) {}
    }
    
    // Try with simpler configuration
    tryFallbackCamera();
  }, 10000); // 10 seconds timeout
  
  // Try to get the back camera
  Html5Qrcode.getCameras()
    .then(devices => {
      if (devices && devices.length) {
        // Prefer back camera (usually the last in the list)
        const cameraId = devices[devices.length - 1].id;
        logDebug(`Found ${devices.length} cameras, using camera ID: ${cameraId}`);
        
        html5QrCode.start(
          cameraId, 
          config, 
          onScanSuccess, 
          onScanFailure
        ).then(() => {
          // Camera started successfully
          if (cameraStartTimeout) {
            clearTimeout(cameraStartTimeout);
            cameraStartTimeout = null;
          }
          
          // Hide loading indicator
          cameraLoading.classList.add('hidden');
          
          logDebug("Camera started successfully");
          
          // Apply CSS to hide the built-in reticule after the camera starts
          setTimeout(() => {
            const scanRegionHighlight = document.getElementById('qr-reader__scan_region_highlight');
            if (scanRegionHighlight) {
              scanRegionHighlight.style.display = 'none';
            }
            
            // Remove any border from the video element
            const videoElements = document.querySelectorAll('#qr-reader video');
            videoElements.forEach(video => {
              video.style.border = 'none';
            });
          }, 500);
        }).catch(err => {
          logDebug("Error starting scanner with selected camera: " + err);
          tryFallbackCamera();
        });
      } else {
        logDebug("No cameras found, trying environment facing mode");
        tryFallbackCamera();
      }
    }).catch(err => {
      logDebug("Error getting cameras: " + err);
      tryFallbackCamera();
    });
}

// Try fallback camera options
function tryFallbackCamera() {
  if (!html5QrCode || !isScanning) return;
  
  logDebug("Trying fallback camera with environment facing mode");
  
  const config = {
    fps: 10,
    qrbox: { width: 250, height: 250 }
  };
  
  html5QrCode.start(
    { facingMode: "environment" },
    config,
    onScanSuccess,
    onScanFailure
  ).then(() => {
    // Camera started successfully
    if (cameraStartTimeout) {
      clearTimeout(cameraStartTimeout);
      cameraStartTimeout = null;
    }
    
    // Hide loading indicator
    cameraLoading.classList.add('hidden');
    
    logDebug("Fallback camera started successfully");
    
    // Apply CSS to hide the built-in reticule
    setTimeout(() => {
      const scanRegionHighlight = document.getElementById('qr-reader__scan_region_highlight');
      if (scanRegionHighlight) {
        scanRegionHighlight.style.display = 'none';
      }
      
      // Remove any border from the video element
      const videoElements = document.querySelectorAll('#qr-reader video');
      videoElements.forEach(video => {
        video.style.border = 'none';
      });
    }, 500);
  }).catch(err => {
    logDebug("Error starting fallback camera: " + err);
    
    // Final fallback - try user facing camera
    logDebug("Trying user facing camera as last resort");
    html5QrCode.start(
      { facingMode: "user" },
      config,
      onScanSuccess,
      onScanFailure
    ).then(() => {
      // Camera started successfully
      if (cameraStartTimeout) {
        clearTimeout(cameraStartTimeout);
        cameraStartTimeout = null;
      }
      
      // Hide loading indicator
      cameraLoading.classList.add('hidden');
      
      logDebug("User facing camera started successfully");
      
      // Apply CSS to hide the built-in reticule
      setTimeout(() => {
        const scanRegionHighlight = document.getElementById('qr-reader__scan_region_highlight');
        if (scanRegionHighlight) {
          scanRegionHighlight.style.display = 'none';
        }
        
        // Remove any border from the video element
        const videoElements = document.querySelectorAll('#qr-reader video');
        videoElements.forEach(video => {
          video.style.border = 'none';
        });
      }, 500);
    }).catch(err => {
      logDebug("All camera options failed: " + err);
      showMessage("Could not start scanner. Please try manual entry.", true);
      stopScanning();
    });
  });
}

// Handle scan failure - just log for debugging
function onScanFailure(error) {
  // We don't need to do anything on failure
  // console.log("QR scan error: " + error);
}

// Play beep sound
function playBeep() {
  try {
    // Try to use AudioContext for better compatibility with silent mode
    if (window.AudioContext || window.webkitAudioContext) {
      // Create an AudioContext
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create an oscillator for the beep sound
      const oscillator = audioContext.createOscillator();
      oscillator.type = 'sine'; // Sine wave ‚Äî a pure tone
      oscillator.frequency.setValueAtTime(1500, audioContext.currentTime); // Value in hertz
      
      // Create a gain node to control volume
      const gainNode = audioContext.createGain();
      gainNode.gain.setValueAtTime(0.25, audioContext.currentTime); // Increase volume
      
      // Connect oscillator to gain node and gain node to output
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      // Start and stop the oscillator to create a short beep
      oscillator.start();
      setTimeout(() => {
        oscillator.stop();
      }, 150); // Longer beep (150ms)
    }
  } catch (e) {
    logDebug("Error playing beep: " + e);
  }
}

// Trigger vibration - improved version that works in silent mode
function vibrate() {
  try {
    // Try standard vibration API with a stronger pattern
    if (navigator.vibrate) {
      // Use a more noticeable vibration pattern (200ms on, 100ms off, 200ms on)
      navigator.vibrate([200, 100, 200]);
      logDebug("Standard vibration triggered");
    }
    
    // Try to force audio to enable haptic feedback on iOS
    // This works because playing audio can trigger the haptic system on iOS
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    // Set up a short, inaudible tone
    oscillator.frequency.value = 1;
    gainNode.gain.value = 0.01; // Very low volume, almost inaudible
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Play the tone briefly
    oscillator.start();
    setTimeout(() => {
      oscillator.stop();
      logDebug("Audio-based haptic feedback attempted");
    }, 50);
  } catch (e) {
    logDebug("Error triggering haptic feedback: " + e);
  }
}

// Handle successful QR scan
function onScanSuccess(decodedText) {
  // Log the raw scanned text for debugging
  logDebug(`Raw QR scan result: ${decodedText}`);
  
  // Show success flash
  flashOverlay.style.display = 'block';
  setTimeout(function() {
    flashOverlay.style.display = 'none';
  }, 500);
  
  // Play beep sound and vibrate
  playBeep();
  vibrate();
  
  // Process scan
  processScan(decodedText);
}

// Process scan data
function processScan(decodedText) {
  // Extract the bib number from the scanned text
  let cleanBib;
  
  // Check if the text contains a comma (BibNumber, RunnerName format)
  if (decodedText.includes(',')) {
    // Split by comma and take the first part as the bib number
    const parts = decodedText.split(',');
    cleanBib = parts[0].trim().replace(/\D/g, '');
    logDebug(`Extracted bib from comma-separated format: ${cleanBib}`);
  } else {
    // If no comma, just clean the whole text
    cleanBib = decodedText.toString().replace(/\D/g, '');
    logDebug(`No comma found, cleaned bib: ${cleanBib}`);
  }
  
  // If no bib number could be extracted, show error
  if (!cleanBib) {
    showMessage(`Could not extract bib number from scan`, true);
    return;
  }
  
  logDebug(`Processing scan for bib: ${cleanBib}`);
  
  // Find runner in our loaded data
  const runnerInfo = runnersData[cleanBib];
  
  if (!runnerInfo) {
    showMessage(`No runner found with bib ${cleanBib}`, true);
    return;
  }
  
  // Check if runner is marked as DNF
  if (runnerInfo.dnf) {
    showMessage(`Runner #${cleanBib} (${runnerInfo.name}) is marked as DNF`, true);
    return;
  }
  
  // Check if we should process this scan (not a duplicate or is newer)
  if (!shouldProcessScan(cleanBib, checkpoint)) {
    showMessage(`Already recorded: ${runnerInfo.name} (${cleanBib})`, false);
    return;
  }
  
  // Check if this runner has already been scanned at this checkpoint
  if (alreadyScannedRunners.has(cleanBib)) {
    showMessage(`Runner #${cleanBib} already scanned at this checkpoint`, false);
    return;
  }
  
  const scanData = {
    timestamp: new Date().toISOString(),
    bib: cleanBib,
    name: runnerInfo.name,
    checkpoint: checkpoint
  };
  
  // Mark as processed to prevent duplicates
  markScanAsProcessed(cleanBib, checkpoint);
  
  // Add to already scanned runners
  alreadyScannedRunners.add(cleanBib);
  
  // Add to recent scans
  storeRecentScan(scanData);
  
  // Update checkpoint stats
  fetchCheckpointStats();
  
  if (isOnline) {
    submitScanToSheet(scanData)
      .then(function(success) {
        if (success) {
          // Mark as uploaded to prevent duplicates
          markScanAsUploaded(scanData);
          showMessage(`Recorded: ${runnerInfo.name} (${cleanBib})`);
        } else {
          showMessage('Error submitting scan. Storing offline.', true);
          storeScanOffline(scanData);
        }
      })
      .catch(function(error) {
        logDebug('Error submitting scan: ' + error);
        showMessage('Error submitting scan. Storing offline.', true);
        storeScanOffline(scanData);
      });
  } else {
    storeScanOffline(scanData);
    showMessage(`Stored offline: ${runnerInfo.name} (${cleanBib})`);
  }
}

// Check if scan is a duplicate and if it's the most recent
function shouldProcessScan(bib, checkpoint) {
  const key = `${bib}-${checkpoint}`;
  
  // If we've never seen this bib+checkpoint, definitely process it
  if (!processedScans[key]) {
    return true;
  }
  
  // If we've seen it before, check if this is a newer scan
  const now = Date.now();
  const lastScanTime = scanTimestamps[key] || 0;
  
  // Only process if it's been at least 5 seconds since the last scan
  // This prevents accidental double-scans
  return (now - lastScanTime) > 5000;
}

// Mark scan as processed
function markScanAsProcessed(bib, checkpoint) {
  const key = `${bib}-${checkpoint}`;
  processedScans[key] = true;
  scanTimestamps[key] = Date.now();
  saveProcessedScans();
  saveScanTimestamps();
}

// Mark scan as uploaded to prevent duplicates
function markScanAsUploaded(scanData) {
  const key = `${scanData.bib}-${scanData.checkpoint}`;
  uploadedScans[key] = true;
  saveUploadedScans();
}

// Check if scan has already been uploaded
function hasBeenUploaded(scanData) {
  const key = `${scanData.bib}-${scanData.checkpoint}`;
  return uploadedScans[key] === true;
}

// Store a recent scan
function storeRecentScan(scanData) {
  try {
    // Add to memory first
    if (recentScans.length >= 10) {
      recentScans.pop(); // Remove the oldest scan
    }
    recentScans.unshift(scanData); // Add new scan at the beginning
    updateRecentScansUI();
    
    // Store in localStorage
    localStorage.setItem('recentScans', JSON.stringify(recentScans));
  } catch (error) {
    logDebug('Error storing recent scan: ' + error);
  }
}

// Store scan offline
function storeScanOffline(scanData) {
  try {
    // Check if we already have a pending upload for this bib+checkpoint
    const existingIndex = pendingUploads.findIndex(
      scan => scan.bib === scanData.bib && scan.checkpoint === scanData.checkpoint
    );
    
    if (existingIndex >= 0) {
      // Replace the existing entry with the newer one
      pendingUploads[existingIndex] = scanData;
    } else {
      // Add to memory
      pendingUploads.push(scanData);
    }
    
    updatePendingUploadsUI();
    
    // Store in localStorage
    localStorage.setItem('pendingUploads', JSON.stringify(pendingUploads));
    logDebug(`Stored scan offline: ${scanData.bib} - ${scanData.name}`);
  } catch (error) {
    logDebug('Error storing scan offline: ' + error);
  }
}

// Submit scan to Google Sheet - CSP-friendly version
function submitScanToSheet(scanData) {
  return new Promise(function(resolve, reject) {
    logDebug(`Submitting scan to sheet: ${scanData.bib} - ${scanData.name} at ${scanData.checkpoint}`);
    
    // Create the data to send
    const data = {
      timestamp: scanData.timestamp,
      bibNumber: scanData.bib,
      runnerName: scanData.name,
      checkpoint: scanData.checkpoint,
      replaceExisting: true
    };
    
    // Use fetch API instead of JSONP
    fetch(`${APPS_SCRIPT_URL}?action=recordScan&data=${encodeURIComponent(JSON.stringify(data))}`, {
      method: 'GET',
      mode: 'no-cors', // This allows the request but won't let you read the response
      cache: 'no-cache'
    })
    .then(() => {
      // Since we can't read the response with no-cors, we'll assume success
      logDebug('Fetch request sent, assuming success');
      resolve(true);
    })
    .catch(error => {
      logDebug('Network error when submitting scan: ' + error);
      // Even with network errors, we'll assume success after a timeout
      // This is because Google Apps Script often processes the request successfully
      // even if the browser reports a CORS error
      resolve(true);
    });
  });
}

// Upload pending scans
function uploadPendingScans(forceUpload = false) {
  if (pendingUploads.length === 0 || (!isOnline && !forceUpload) || isUploadingPendingScans) return;
  
  isUploadingPendingScans = true;
  logDebug(`Attempting to upload ${pendingUploads.length} pending scans`);
  
  // Process each scan one at a time
  uploadNextScan(0);
  
  function uploadNextScan(index) {
    if (index >= pendingUploads.length) {
      // All done
      logDebug('Finished uploading pending scans');
      isUploadingPendingScans = false;
      
      // Update checkpoint stats after uploads
      fetchCheckpointStats();
      return;
    }
    
    const scanData = pendingUploads[index];
    logDebug(`Uploading pending scan ${index + 1}/${pendingUploads.length}: ${scanData.bib} at ${scanData.checkpoint}`);
    
    submitScanToSheet(scanData)
      .then(success => {
        // Always remove from pending uploads and assume success
        // This is because with CORS, we can't reliably determine if the upload failed
        logDebug(`Processed scan: ${scanData.bib} at ${scanData.checkpoint}`);
        
        // Remove this scan from pendingUploads
        pendingUploads.splice(index, 1);
        
        // Update localStorage
        localStorage.setItem('pendingUploads', JSON.stringify(pendingUploads));
        updatePendingUploadsUI();
        
        // Continue with the next scan (same index since we removed one)
        setTimeout(() => uploadNextScan(index), 1000);
      })
      .catch(error => {
        logDebug(`Error uploading scan: ${error}`);
        // Move to the next scan
        setTimeout(() => uploadNextScan(index + 1), 1000);
      });
  }
}

// Handle manual bib submission
manualSubmitButton.addEventListener('click', function() {
  const bib = bibInput.value.trim();
  
  if (!bib) {
    showMessage('Please enter a bib number', true);
    return;
  }
  
  // Find runner in our loaded data
  const runnerInfo = runnersData[bib];
  
  if (!runnerInfo) {
    showMessage(`No runner found with bib ${bib}`, true);
    return;
  }
  
  // Check if runner is marked as DNF
  if (runnerInfo.dnf) {
    showMessage(`Runner #${bib} (${runnerInfo.name}) is marked as DNF`, true);
    return;
  }
  
  // Check if we should process this scan (not a duplicate or is newer)
  if (!shouldProcessScan(bib, checkpoint)) {
    showMessage(`Already recorded: ${runnerInfo.name} (${bib})`, false);
    bibInput.value = '';
    return;
  }
  
  // Check if this runner has already been scanned at this checkpoint
  if (alreadyScannedRunners.has(bib)) {
    showMessage(`Runner #${bib} already scanned at this checkpoint`, false);
    bibInput.value = '';
    return;
  }
  
  const scanData = {
    timestamp: new Date().toISOString(),
    bib: bib,
    name: runnerInfo.name,
    checkpoint: checkpoint
  };
  
  // Mark as processed to prevent duplicates
  markScanAsProcessed(bib, checkpoint);
  
  // Add to already scanned runners
  alreadyScannedRunners.add(bib);
  
  // Play beep sound and vibrate
  playBeep();
  vibrate();
  
  // Add to recent scans
  storeRecentScan(scanData);
  
  // Update checkpoint stats
  fetchCheckpointStats();
  
  if (isOnline) {
    submitScanToSheet(scanData)
      .then(function(success) {
        if (success) {
          // Mark as uploaded to prevent duplicates
          markScanAsUploaded(scanData);
          showMessage(`Recorded: ${runnerInfo.name} (${bib})`);
          // Clear form
          bibInput.value = '';
        } else {
          showMessage('Error submitting entry. Storing offline.', true);
          storeScanOffline(scanData);
          // Still clear the form
          bibInput.value = '';
        }
      })
      .catch(function(error) {
        logDebug('Error submitting manual entry: ' + error);
        showMessage('Error submitting entry. Storing offline.', true);
        storeScanOffline(scanData);
        // Still clear the form
        bibInput.value = '';
      });
  } else {
    storeScanOffline(scanData);
    showMessage(`Stored offline: ${runnerInfo.name} (${bib})`);
    // Clear form
    bibInput.value = '';
  }
});

// Show message
function showMessage(text, isError = false) {
  messageDisplay.textContent = text;
  messageDisplay.classList.remove('hidden');
  
  if (isError) {
    messageDisplay.classList.remove('success-message');
    messageDisplay.classList.add('error-message');
  } else {
    messageDisplay.classList.remove('error-message');
    messageDisplay.classList.add('success-message');
  }
  
  // Hide message after 3 seconds
  setTimeout(function() {
    messageDisplay.classList.add('hidden');
  }, 3000);
}

// Initialize the app
init();
});
</script>
</body>
</html>
