<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tiger Claw Timing System</title>
<style>
  /* Basic styling */
  * {
    box-sizing: border-box;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  }
  
  #tiger-claw-app {
    max-width: 500px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f9f9f9;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  }
  
  .app-header {
    text-align: center;
    margin-bottom: 20px;
  }
  
  .app-header h1 {
    color: #1e7e34;
    margin-bottom: 5px;
  }
  
  .form-group {
    margin-bottom: 15px;
  }
  
  label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
  }
  
  select, input, button {
    width: 100%;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    font-size: 16px;
  }
  
  button {
    background-color: #28a745;
    color: white;
    border: none;
    cursor: pointer;
    font-weight: bold;
    margin-top: 10px;
    padding: 12px;
  }
  
  button:hover {
    background-color: #218838;
  }
  
  button:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
  }
  
  .error-message {
    color: #dc3545;
    margin-top: 5px;
    font-size: 14px;
  }
  
  .success-message {
    color: #28a745;
    margin-top: 5px;
    font-size: 14px;
  }
  
  .connection-status {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px;
    font-size: 14px;
  }
  
  .status-connected {
    color: #28a745;
  }
  
  .status-disconnected {
    color: #dc3545;
  }
  
  .status-icon {
    margin-right: 5px;
  }
  
  .hidden {
    display: none !important;
  }
  
  .scanner-container {
    position: relative;
    margin: 10px 0;
    /* Make scanner more prominent and higher in the view */
    max-width: 350px;
    margin-left: auto;
    margin-right: auto;
  }
  
  /* QR reader container - let it use natural aspect ratio */
  #qr-reader {
    width: 100% !important;
    border: none !important;
    box-shadow: none !important;
    position: relative;
    overflow: hidden;
    border-radius: 8px;
    background-color: transparent !important;
  }
  
  /* Fix for black rectangle */
  #qr-reader__dashboard_section_csr {
    background: transparent !important;
    padding: 0 !important;
    display: none !important;
  }
  
  #qr-reader__scan_region {
    background: transparent !important;
  }
  
  #qr-reader video {
    max-height: 300px !important;
    object-fit: cover !important;
  }
  
  /* Make sure only one camera view is visible */
  #qr-reader__scan_region video:nth-child(n+2) {
    display: none !important;
  }
  
  #qr-reader__status_span {
    display: none !important;
    background-color: #f0fdf4 !important;
    color: #166534 !important;
  }
  
  /* Targeting overlay - adapt to the actual camera view */
  .targeting-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5;
  }
  
  .targeting-overlay::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 70%;
    height: 70%;
    border: 2px dashed #28a745;
    border-radius: 8px;
  }
  
  .targeting-overlay::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    border: 2px solid #28a745;
    border-radius: 50%;
  }
  
  .flash-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(40, 167, 69, 0.7);
    z-index: 10;
    display: none;
    border-radius: 8px;
  }
  
  .pending-uploads {
    background-color: #fff3cd;
    color: #856404;
    padding: 10px;
    border-radius: 5px;
    margin-top: 15px;
    font-size: 14px;
  }
  
  .loading-spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(0, 0, 0, 0.1);
    border-radius: 50%;
    border-top-color: #28a745;
    animation: spin 1s ease-in-out infinite;
    margin-right: 10px;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  /* QR Scanner customizations */
  #qr-reader__scan_region {
    min-height: 300px;
  }
  
  /* Hide unnecessary elements */
  #qr-reader__dashboard_section_swaplink,
  #qr-reader__dashboard_section_csr button,
  #qr-reader__camera_selection,
  #qr-reader__filescan_input,
  #qr-reader__filescan_input + span {
    display: none !important;
  }
  
  /* Hide the built-in QR scanner border */
  #qr-reader video {
    border: none !important;
  }
  
  /* Hide the built-in QR scanner reticule */
  #qr-reader__scan_region_highlight {
    display: none !important;
  }
  
  /* Recent scans list */
  .recent-scans {
    margin-top: 20px;
    border-top: 1px solid #ddd;
    padding-top: 10px;
  }
  
  .recent-scans h3 {
    margin-top: 0;
    font-size: 16px;
  }
  
  .scan-item {
    padding: 8px;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
  }
  
  .scan-item:last-child {
    border-bottom: none;
  }
  
  .scan-bib {
    font-weight: bold;
  }
  
  .scan-time {
    color: #666;
    font-size: 14px;
  }
  
  /* Debug panel */
  .debug-panel {
    margin-top: 20px;
    padding: 10px;
    background-color: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 5px;
    font-size: 12px;
  }
  
  .debug-panel h4 {
    margin-top: 0;
    margin-bottom: 5px;
  }
  
  .debug-panel pre {
    margin: 0;
    white-space: pre-wrap;
    word-break: break-all;
  }
  
  /* Native camera fallback */
  #native-camera-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 20px 0;
  }
  
  #native-camera-video {
    width: 100%;
    max-width: 350px;
    border-radius: 8px;
    background-color: #000;
    object-fit: cover;
  }
  
  #native-camera-canvas {
    display: none;
  }
  
  /* Camera instructions */
  .camera-instructions {
    text-align: center;
    margin: 10px 0;
    font-size: 14px;
    color: #666;
  }
  
  /* Manual entry section - make it more compact when scanner is active */
  .scanner-active .manual-entry-section {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #ddd;
  }
  
  .scanner-active .manual-entry-section h2 {
    font-size: 16px;
    margin-top: 0;
    margin-bottom: 10px;
  }
  
  /* Camera loading indicator */
  .camera-loading {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border-radius: 8px;
    z-index: 10;
  }
  
  .camera-loading .spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: white;
    animation: spin 1s ease-in-out infinite;
    margin-bottom: 10px;
  }

  /* Center connection status and refresh button */
.connection-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  margin-bottom: 15px;
}

#refresh-button {
  background-color: #28a745;
  margin: 5px auto;
  display: block;
  width: auto;
  font-size: 12px;
  padding: 5px 10px;
  max-width: 200px;
}

  
</style>
</head>
<body>
<div id="tiger-claw-app">
  <!-- Loading Screen -->
  <div id="loading-screen">
    <div class="app-header">
      <h1>TIGER CLAW TIMING SYSTEM</h1>
      <p>Loading runner data...</p>
      <div class="loading-spinner"></div>
    </div>
  </div>
  
  <!-- Login Screen -->
  <div id="login-screen" class="hidden">
    <div class="app-header">
      <h1>TIGER CLAW TIMING SYSTEM</h1>
    </div>
    
    <div class="form-group">
      <label for="checkpoint-select">Select Checkpoint</label>
      <select id="checkpoint-select">
        <option value="">Select checkpoint</option>
        <option value="GREEN CHECKPOINT">GREEN CHECKPOINT</option>
        <option value="PINK LOOP TOP">PINK LOOP TOP</option>
        <option value="PINK LOOP BOTTOM">PINK LOOP BOTTOM</option>
        <option value="YELLOW LOOP TOP">YELLOW LOOP TOP</option>
        <option value="YELLOW LOOP BOTTOM">YELLOW LOOP BOTTOM</option>
        <option value="WHITE LOOP TOP">WHITE LOOP TOP</option>
        <option value="WHITE LOOP BOTTOM">WHITE LOOP BOTTOM</option>
        <option value="RED CHECKPOINT">RED CHECKPOINT</option>
        <option value="FINISHLINE">FINISHLINE</option>
      </select>
    </div>
    
    <div class="form-group">
      <label for="password-input">Password</label>
      <input type="password" id="password-input" placeholder="Enter password">
      <div id="login-error" class="error-message hidden"></div>
    </div>
    
    <button id="login-button">Login</button>
    
    <!-- Debug panel toggle -->
    <div style="margin-top: 20px; text-align: center;">
      <button id="toggle-debug" style="background-color: #6c757d; width: auto; font-size: 12px; padding: 5px 10px;">Show Debug Panel</button>
    </div>
  </div>
  
  <!-- Scanner Screen -->
  <div id="scanner-screen" class="hidden">
    <div class="app-header">
      <h1>TIGER CLAW TIMING</h1>
      <div id="checkpoint-display" style="font-weight: bold; font-size: 18px; margin: 10px 0;"></div>
      <!-- Replace your existing connection status div with this -->
<div class="connection-container">
  <div id="connection-status" class="connection-status">
    <span id="status-icon" class="status-icon">‚óè</span>
    <span id="status-text">CHECKING CONNECTION...</span>
  </div>
  <button id="refresh-button">Refresh Connection</button>
</div>
    </div>
    
    <button id="scan-button" class="scan-button">START SCANNING</button>
    
    <!-- HTML5QrCode scanner container -->
    <div id="scanner-container" class="scanner-container hidden">
      <div id="qr-reader"></div>
      <div class="targeting-overlay"></div>
      <div id="flash-overlay" class="flash-overlay"></div>
      <div id="camera-loading" class="camera-loading">
        <div class="spinner"></div>
        <div>Starting camera...</div>
      </div>
      <div class="camera-instructions">Align QR code within the target</div>
    </div>
    
    <!-- Native camera fallback -->
    <div id="native-camera-container" class="hidden">
      <video id="native-camera-video" autoplay playsinline></video>
      <canvas id="native-camera-canvas"></canvas>
      <div class="camera-instructions">Align QR code within the target</div>
    </div>
    
    <div id="message" class="success-message hidden"></div>
    
    <div class="form-group manual-entry-section" style="margin-top: 20px;">
      <h2>Manual Entry</h2>
      <div class="form-group">
        <label for="bib-input">Bib Number (required)</label>
        <input type="tel" id="bib-input" inputmode="numeric" pattern="[0-9]*" placeholder="Enter bib number">
      </div>
      
      <button id="manual-submit-button">SUBMIT</button>
    </div>
    
    <div id="pending-uploads" class="pending-uploads hidden"></div>
    
    <div id="recent-scans" class="recent-scans">
      <h3>Recent Scans</h3>
      <div id="scans-list"></div>
    </div>
    
    <button id="logout-button" style="background-color: #6c757d; margin-top: 20px;">Logout</button>
    
    <!-- Debug panel (hidden by default) -->
    <div id="debug-panel" class="debug-panel hidden">
      <h4>Debug Info</h4>
      <pre id="debug-info"></pre>
      <button id="force-upload" style="background-color: #6c757d; margin-top: 10px; font-size: 12px;">Force Upload Pending Scans</button>
      <button id="clear-data" style="background-color: #dc3545; margin-top: 10px; font-size: 12px;">Clear All Data</button>
    </div>
  </div>
</div>

<!-- Include the HTML5 QR Code Scanner library directly in the HTML -->
<script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

<script>
  // Main application code
  // Add this event listener with your other event listeners
document.getElementById('refresh-button').addEventListener('click', function() {
  logDebug('Manual connection refresh requested');
  
  // Check connection
  const currentOnlineStatus = navigator.onLine;
  logDebug(`Current connection status: ${currentOnlineStatus ? 'online' : 'offline'}`);
  
  if (currentOnlineStatus) {
    showMessage('Checking for pending uploads...');
    uploadPendingScans(true);
  } else {
    showMessage('No internet connection available', true);
  }
});
  document.addEventListener('DOMContentLoaded', function() {
    // DOM Elements
    const loadingScreen = document.getElementById('loading-screen');
    const loginScreen = document.getElementById('login-screen');
    const scannerScreen = document.getElementById('scanner-screen');
    const checkpointSelect = document.getElementById('checkpoint-select');
    const passwordInput = document.getElementById('password-input');
    const loginButton = document.getElementById('login-button');
    const loginError = document.getElementById('login-error');
    const checkpointDisplay = document.getElementById('checkpoint-display');
    const scanButton = document.getElementById('scan-button');
    const scannerContainer = document.getElementById('scanner-container');
    const nativeCameraContainer = document.getElementById('native-camera-container');
    const nativeCameraVideo = document.getElementById('native-camera-video');
    const nativeCameraCanvas = document.getElementById('native-camera-canvas');
    const flashOverlay = document.getElementById('flash-overlay');
    const cameraLoading = document.getElementById('camera-loading');
    const messageDisplay = document.getElementById('message');
    const bibInput = document.getElementById('bib-input');
    const manualSubmitButton = document.getElementById('manual-submit-button');
    const logoutButton = document.getElementById('logout-button');
    const connectionStatus = document.getElementById('connection-status');
    const statusIcon = document.getElementById('status-icon');
    const statusText = document.getElementById('status-text');
    const pendingUploadsContainer = document.getElementById('pending-uploads');
    const scansList = document.getElementById('scans-list');
    const debugPanel = document.getElementById('debug-panel');
    const debugInfo = document.getElementById('debug-info');
    const toggleDebugBtn = document.getElementById('toggle-debug');
    const forceUploadBtn = document.getElementById('force-upload');
    const clearDataBtn = document.getElementById('clear-data');
    
    // Application state
    let isScanning = false;
    let isOnline = navigator.onLine;
    let html5QrCode = null;
    let checkpoint = '';
    let pendingUploads = [];
    let runnersData = {}; // Will store all runners data
    let recentScans = []; // Store recent scans for display
    let lastUploadAttempt = 0; // Track last upload attempt time
    let debugMode = false; // Debug mode flag
    let useNativeCamera = false; // Whether to use native camera API as fallback
    let nativeCameraStream = null; // Store the camera stream
    let processedScans = {}; // Track processed scans to prevent duplicates
    let scanTimestamps = {}; // Track timestamps of scans to ensure we only keep the most recent
    let cameraStartTimeout = null; // Timeout for camera start
    let isUploadingPendingScans = false; // Flag to prevent multiple simultaneous uploads
    let uploadedScans = {}; // Track which scans have been uploaded to prevent duplicates
    
    // Constants
    const CORRECT_PASSWORD = "threeloops";
    const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbz1vMTB9jSG8E8GXyrVe_QcTKYaCGrxRxPBiE7QpBHsHVwVNjqhj8s9d1hprsupeOSO/exec";
    
    // Toggle debug panel
    toggleDebugBtn.addEventListener('click', function() {
      debugMode = !debugMode;
      if (debugMode) {
        debugPanel.classList.remove('hidden');
        toggleDebugBtn.textContent = 'Hide Debug Panel';
      } else {
        debugPanel.classList.add('hidden');
        toggleDebugBtn.textContent = 'Show Debug Panel';
      }
    });
    
    // Force upload pending scans
    forceUploadBtn.addEventListener('click', function() {
      logDebug('Manually forcing upload of pending scans');
      uploadPendingScans(true);
    });
    
    // Clear all data
    clearDataBtn.addEventListener('click', function() {
      if (confirm('Are you sure you want to clear all data? This will delete all stored runner data and scans.')) {
        clearAllData();
      }
    });
    
    // Clear all data from localStorage
    function clearAllData() {
      try {
        localStorage.removeItem('pendingUploads');
        localStorage.removeItem('recentScans');
        localStorage.removeItem('runnersData');
        localStorage.removeItem('processedScans');
        localStorage.removeItem('scanTimestamps');
        localStorage.removeItem('uploadedScans');
        
        pendingUploads = [];
        recentScans = [];
        runnersData = {};
        processedScans = {};
        scanTimestamps = {};
        uploadedScans = {};
        
        updatePendingUploadsUI();
        updateRecentScansUI();
        
        logDebug('All data cleared successfully');
        showMessage('All data cleared successfully');
      } catch (error) {
        logDebug('Error clearing data: ' + error);
        showMessage('Error clearing data', true);
      }
    }
    
    // Log to debug panel
    function logDebug(message) {
      const timestamp = new Date().toLocaleTimeString();
      if (debugInfo) {
        debugInfo.textContent = `[${timestamp}] ${message}
` + debugInfo.textContent;
      }
      console.log(message);
    }
    
   // Initialize the application - UPDATED
function init() {
  // Load data from localStorage
  loadPendingScans();
  loadRecentScans();
  loadProcessedScans();
  loadScanTimestamps();
  loadUploadedScans();
  
  // Set initial online status
  isOnline = navigator.onLine;
  
  // Fetch runner data
  fetchRunnerData();
  
  // Set up online/offline event listeners
  window.addEventListener('online', handleOnlineStatusChange);
  window.addEventListener('offline', handleOnlineStatusChange);
  
  // Check if we have pending uploads and we're online
  if (isOnline && pendingUploads.length > 0) {
    logDebug(`Found ${pendingUploads.length} pending uploads at startup - attempting to upload`);
    setTimeout(() => {
      uploadPendingScans(true);
    }, 3000);
  }
}
    // Load uploaded scans from localStorage
    function loadUploadedScans() {
      try {
        const storedUploadedScans = localStorage.getItem('uploadedScans');
        if (storedUploadedScans) {
          uploadedScans = JSON.parse(storedUploadedScans);
          logDebug(`Loaded uploaded scans tracking data from localStorage`);
        }
      } catch (error) {
        logDebug('Error loading uploaded scans: ' + error);
        uploadedScans = {};
      }
    }
    
    // Save uploaded scans to localStorage
    function saveUploadedScans() {
      try {
        localStorage.setItem('uploadedScans', JSON.stringify(uploadedScans));
      } catch (error) {
        logDebug('Error saving uploaded scans: ' + error);
      }
    }
    
    // Load processed scans from localStorage
    function loadProcessedScans() {
      try {
        const storedProcessedScans = localStorage.getItem('processedScans');
        if (storedProcessedScans) {
          processedScans = JSON.parse(storedProcessedScans);
          logDebug(`Loaded processed scans tracking data from localStorage`);
        }
      } catch (error) {
        logDebug('Error loading processed scans: ' + error);
        processedScans = {};
      }
    }
    
    // Load scan timestamps from localStorage
    function loadScanTimestamps() {
      try {
        const storedTimestamps = localStorage.getItem('scanTimestamps');
        if (storedTimestamps) {
          scanTimestamps = JSON.parse(storedTimestamps);
          logDebug(`Loaded scan timestamps from localStorage`);
        }
      } catch (error) {
        logDebug('Error loading scan timestamps: ' + error);
        scanTimestamps = {};
      }
    }
    
    // Save processed scans to localStorage
    function saveProcessedScans() {
      try {
        localStorage.setItem('processedScans', JSON.stringify(processedScans));
      } catch (error) {
        logDebug('Error saving processed scans: ' + error);
      }
    }
    
    // Save scan timestamps to localStorage
    function saveScanTimestamps() {
      try {
        localStorage.setItem('scanTimestamps', JSON.stringify(scanTimestamps));
      } catch (error) {
        logDebug('Error saving scan timestamps: ' + error);
      }
    }
    
// Handle online/offline status changes
function handleOnlineStatusChange() {
  const wasOnline = isOnline;
  isOnline = navigator.onLine;
  
  logDebug(`Connection status changed: ${wasOnline ? 'online' : 'offline'} -> ${isOnline ? 'online' : 'offline'}`);
  updateConnectionStatus();
  
  // If we're back online and have offline entries, try to sync them
  if (isOnline && !wasOnline && pendingUploads.length > 0) {
    logDebug('Connection restored - attempting to upload pending scans');
    // Wait a moment for the connection to stabilize
    setTimeout(() => {
      uploadPendingScans(true);
    }, 2000);
  }
}
    
    // Load pending scans from localStorage
    function loadPendingScans() {
      try {
        const storedUploads = localStorage.getItem('pendingUploads');
        if (storedUploads) {
          pendingUploads = JSON.parse(storedUploads);
          logDebug(`Loaded ${pendingUploads.length} pending scans from localStorage`);
          updatePendingUploadsUI();
        }
      } catch (error) {
        logDebug('Error loading pending scans: ' + error);
        pendingUploads = [];
      }
    }
    
    // Load recent scans from localStorage
    function loadRecentScans() {
      try {
        const storedScans = localStorage.getItem('recentScans');
        if (storedScans) {
          recentScans = JSON.parse(storedScans);
          logDebug(`Loaded ${recentScans.length} recent scans from localStorage`);
          updateRecentScansUI();
        }
      } catch (error) {
        logDebug('Error loading recent scans: ' + error);
        recentScans = [];
      }
    }
    
// Declare variables
let logDebug;
let runnersData;
let loadingScreen;
let checkLoginStatus;
let APPS_SCRIPT_URL;

// Fetch runner data from Google Sheets using JSONP
function fetchRunnerData() {
  logDebug('Fetching runner data from Google Sheets...');
  
  // Try to load from localStorage first
  try {
    const storedData = localStorage.getItem('runnersData');
    if (storedData) {
      const parsedData = JSON.parse(storedData);
      if (parsedData && Object.keys(parsedData).length > 0) {
        runnersData = parsedData;
        logDebug(`Loaded ${Object.keys(runnersData).length} runners from localStorage`);
        loadingScreen.classList.add('hidden');
        checkLoginStatus();
        return;
      }
    }
  } catch (error) {
    logDebug('Error loading runners data from localStorage: ' + error);
  }
  
  // Create a unique callback name
  const callbackName = 'runnersCallback_' + Date.now();
  
  // Define the callback function
  window[callbackName] = function(response) {
    // Clean up
    document.body.removeChild(script);
    delete window[callbackName];
    
    logDebug('JSONP response received for runners data');
    
    try {
      if (response && response.success && response.data) {
        const runnerMap = {};
        response.data.forEach(runner => {
          runnerMap[runner.bibNumber] = runner.name;
        });
        runnersData = runnerMap;
        
        // Store in localStorage for future use
        localStorage.setItem('runnersData', JSON.stringify(runnersData));
        
        logDebug(`Loaded ${Object.keys(runnersData).length} runners from Google Sheets`);
      } else {
        logDebug('Invalid or empty runners data format from API');
      }
    } catch (error) {
      logDebug('Error processing runner data: ' + error);
    }
    
    loadingScreen.classList.add('hidden');
    checkLoginStatus();
  };
  
  // Create the script element for JSONP
  const script = document.createElement('script');
  script.src = `${APPS_SCRIPT_URL}?action=getRunnerData&callback=${callbackName}&nocache=${Date.now()}`;
  
  // Handle errors
  script.onerror = function() {
    // Clean up
    delete window[callbackName];
    document.body.removeChild(script);
    
    logDebug('Error fetching runner data');
    loadingScreen.classList.add('hidden');
    checkLoginStatus();
  };
  
  // Add the script to the document
  document.body.appendChild(script);
  
  // Set a timeout to handle case where script doesn't load or callback isn't called
  setTimeout(() => {
    if (window[callbackName]) {
      delete window[callbackName];
      logDebug('Timeout fetching runner data');
      loadingScreen.classList.add('hidden');
      checkLoginStatus();
    }
  }, 10000); // 10 seconds timeout
}
    
    
    // Update recent scans UI
    function updateRecentScansUI() {
      scansList.innerHTML = '';
      
      if (recentScans.length === 0) {
        scansList.innerHTML = '<p>No scans yet</p>';
        return;
      }
      
      recentScans.forEach(scan => {
        const scanTime = new Date(scan.timestamp).toLocaleTimeString();
        const scanItem = document.createElement('div');
        scanItem.className = 'scan-item';
        scanItem.innerHTML = `
          <div>
            <span class="scan-bib">#${scan.bib}</span> - ${scan.name}
          </div>
          <div class="scan-time">${scanTime}</div>
        `;
        scansList.appendChild(scanItem);
      });
    }
    
    // Update pending uploads UI - IMPROVED VERSION
function updatePendingUploadsUI() {
  if (pendingUploads.length > 0) {
    pendingUploadsContainer.classList.remove('hidden');
    pendingUploadsContainer.textContent = `${pendingUploads.length} scan${pendingUploads.length > 1 ? 's' : ''} pending upload. Data will be uploaded automatically when connection is restored.`;
  } else {
    pendingUploadsContainer.classList.add('hidden');
    pendingUploadsContainer.textContent = '';
  }
  
  // Log the current state for debugging
  logDebug(`Pending uploads UI updated: ${pendingUploads.length} scans pending`);
}
    
// Declare variables
let isOnline = navigator.onLine;
let pendingUploads = [];
let lastUploadAttempt = 0;

    
// Update connection status UI and check connectivity
function updateConnectionStatus() {
  // First check navigator.onLine
  isOnline = navigator.onLine;

  // If navigator.onLine says we're online, do an additional check
  if (isOnline) {
    // Create a unique callback name
    const callbackName = 'pingCallback_' + Date.now();
    
    // Define the callback function
    window[callbackName] = function(response) {
      // Clean up
      document.body.removeChild(script);
      delete window[callbackName];
      
      // If we get here, we're definitely online
      isOnline = true;
      updateConnectionStatusUI();
      
      // Try to upload pending scans if we have any
      if (pendingUploads.length > 0) {
        // Only attempt upload if it's been more than 5 seconds since last attempt
        const now = Date.now();
        if (now - lastUploadAttempt > 5000) {
          lastUploadAttempt = now;
          uploadPendingScans();
        }
      }
    };
    
    // Create the script element for JSONP
    const script = document.createElement('script');
    script.src = `${APPS_SCRIPT_URL}?action=ping&callback=${callbackName}&nocache=${Date.now()}`;
    
    // Handle errors
    script.onerror = function() {
      // Clean up
      delete window[callbackName];
      document.body.removeChild(script);
      
      // If the fetch fails, we're offline despite what navigator.onLine says
      isOnline = false;
      updateConnectionStatusUI();
    };
    
    // Add the script to the document
    document.body.appendChild(script);
    
    // Set a timeout to handle case where script doesn't load or callback isn't called
    setTimeout(() => {
      if (window[callbackName]) {
        delete window[callbackName];
        // If we get here, the callback wasn't called, so we're offline
        isOnline = false;
        updateConnectionStatusUI();
      }
    }, 5000);
  } else {
    // We're definitely offline according to navigator.onLine
    updateConnectionStatusUI();
  }
}
    
    // Check if user is already logged in
    function checkLoginStatus() {
      const savedCheckpoint = localStorage.getItem('tigerClawCheckpoint');
      if (savedCheckpoint) {
        checkpoint = savedCheckpoint;
        showScannerScreen();
      } else {
        loginScreen.classList.remove('hidden');
      }
    }
    
    // Show scanner screen
    function showScannerScreen() {
      loginScreen.classList.add('hidden');
      loadingScreen.classList.add('hidden');
      scannerScreen.classList.remove('hidden');
      checkpointDisplay.textContent = checkpoint;
      updateConnectionStatus();
    }
    
    // Show login screen
    function showLoginScreen() {
      scannerScreen.classList.add('hidden');
      loadingScreen.classList.add('hidden');
      loginScreen.classList.remove('hidden');
      
      // Clear form
      checkpointSelect.value = '';
      passwordInput.value = '';
      loginError.classList.add('hidden');
    }
    
    // Handle login
    loginButton.addEventListener('click', function() {
      const selectedCheckpoint = checkpointSelect.value;
      const password = passwordInput.value;
      
      if (!selectedCheckpoint) {
        loginError.textContent = 'Please select a checkpoint';
        loginError.classList.remove('hidden');
        return;
      }
      
      if (password !== CORRECT_PASSWORD) {
        loginError.textContent = 'Incorrect password';
        loginError.classList.remove('hidden');
        return;
      }
      
      // Save checkpoint and show scanner screen
      checkpoint = selectedCheckpoint;
      localStorage.setItem('tigerClawCheckpoint', checkpoint);
      showScannerScreen();
    });
    
    // Handle logout
    logoutButton.addEventListener('click', function() {
      // Stop scanner if running
      stopScanning();
      
      localStorage.removeItem('tigerClawCheckpoint');
      showLoginScreen();
    });
    
    // Stop scanning (both HTML5QrCode and native camera)
    function stopScanning() {
      if (isScanning) {
        // Clear any pending camera start timeout
        if (cameraStartTimeout) {
          clearTimeout(cameraStartTimeout);
          cameraStartTimeout = null;
        }
        
        if (html5QrCode) {
          try {
            html5QrCode.stop().catch(err => {
              logDebug("Error stopping HTML5QrCode scanner: " + err);
            });
            html5QrCode = null;
          } catch (e) {
            logDebug("Error stopping HTML5QrCode scanner: " + e);
          }
        }
        
        if (nativeCameraStream) {
          try {
            nativeCameraStream.getTracks().forEach(track => track.stop());
            nativeCameraStream = null;
          } catch (e) {
            logDebug("Error stopping native camera: " + e);
          }
        }
        
        isScanning = false;
        scannerContainer.classList.add('hidden');
        nativeCameraContainer.classList.add('hidden');
        scanButton.textContent = 'START SCANNING';
        scanButton.style.backgroundColor = '#28a745';
        
        // Remove scanner-active class from scanner screen
        scannerScreen.classList.remove('scanner-active');
      }
    }
    
    // Toggle scanner
    scanButton.addEventListener('click', function() {
      if (isScanning) {
        stopScanning();
      } else {
        // Start scanning
        isScanning = true;
        scanButton.textContent = 'STOP SCANNING';
        scanButton.style.backgroundColor = '#dc3545';
        
        // Add scanner-active class to scanner screen
        scannerScreen.classList.add('scanner-active');
        
        // Start the scanner
        startScanner();
      }
    });
    
    // Start QR scanner with back camera - COMPLETELY REVISED VERSION
    function startScanner() {
      try {
        // First, ensure any existing scanner is properly stopped
        if (html5QrCode) {
          try {
            html5QrCode.stop().then(() => {
              logDebug("Previous scanner stopped successfully");
            }).catch(err => {
              logDebug("Error stopping previous scanner: " + err);
            }).finally(() => {
              html5QrCode = null;
              initializeNewScanner();
            });
          } catch (e) {
            logDebug("Error stopping existing scanner: " + e);
            html5QrCode = null;
            initializeNewScanner();
          }
        } else {
          initializeNewScanner();
        }
      } catch (error) {
        logDebug("Error in startScanner: " + error);
        showMessage("Error initializing scanner. Please try manual entry.", true);
        stopScanning();
      }
    }

    // Separate function to initialize a new scanner
    function initializeNewScanner() {
      // Clear any existing HTML in the qr-reader div
      const qrReaderElement = document.getElementById('qr-reader');
      if (qrReaderElement) {
        qrReaderElement.innerHTML = '';
      }
      
      // Show the scanner container with loading indicator
      scannerContainer.classList.remove('hidden');
      cameraLoading.classList.remove('hidden');
      nativeCameraContainer.classList.add('hidden');
      
      // Create a new instance of the QR scanner
      html5QrCode = new Html5Qrcode("qr-reader");
      
      // Simple configuration that works reliably
      const config = {
        fps: 10,
        qrbox: { width: 250, height: 250 },
        rememberLastUsedCamera: true,
        aspectRatio: 1.0
      };
      
      // Clear any existing timeout
      if (cameraStartTimeout) {
        clearTimeout(cameraStartTimeout);
      }
      
      // Set a timeout to detect if camera doesn't start
      cameraStartTimeout = setTimeout(() => {
        logDebug("Camera start timeout - trying fallback");
        if (html5QrCode) {
          try {
            html5QrCode.stop().catch(() => {});
          } catch (e) {}
        }
        
        // Try with simpler configuration
        tryFallbackCamera();
      }, 10000); // 10 seconds timeout
      
      // Try to get the back camera
      Html5Qrcode.getCameras()
        .then(devices => {
          if (devices && devices.length) {
            // Prefer back camera (usually the last in the list)
            const cameraId = devices[devices.length - 1].id;
            logDebug(`Found ${devices.length} cameras, using camera ID: ${cameraId}`);
            
            html5QrCode.start(
              cameraId, 
              config, 
              onScanSuccess, 
              onScanFailure
            ).then(() => {
              // Camera started successfully
              if (cameraStartTimeout) {
                clearTimeout(cameraStartTimeout);
                cameraStartTimeout = null;
              }
              
              // Hide loading indicator
              cameraLoading.classList.add('hidden');
              
              logDebug("Camera started successfully");
              
              // Apply CSS to hide the built-in reticule after the camera starts
              setTimeout(() => {
                const scanRegionHighlight = document.getElementById('qr-reader__scan_region_highlight');
                if (scanRegionHighlight) {
                  scanRegionHighlight.style.display = 'none';
                }
                
                // Remove any border from the video element
                const videoElements = document.querySelectorAll('#qr-reader video');
                videoElements.forEach(video => {
                  video.style.border = 'none';
                });
              }, 500);
            }).catch(err => {
              logDebug("Error starting scanner with selected camera: " + err);
              tryFallbackCamera();
            });
          } else {
            logDebug("No cameras found, trying environment facing mode");
            tryFallbackCamera();
          }
        }).catch(err => {
          logDebug("Error getting cameras: " + err);
          tryFallbackCamera();
        });
    }
    
    // Try fallback camera options
    function tryFallbackCamera() {
      if (!html5QrCode || !isScanning) return;
      
      logDebug("Trying fallback camera with environment facing mode");
      
      const config = {
        fps: 10,
        qrbox: { width: 250, height: 250 }
      };
      
      html5QrCode.start(
        { facingMode: "environment" },
        config,
        onScanSuccess,
        onScanFailure
      ).then(() => {
        // Camera started successfully
        if (cameraStartTimeout) {
          clearTimeout(cameraStartTimeout);
          cameraStartTimeout = null;
        }
        
        // Hide loading indicator
        cameraLoading.classList.add('hidden');
        
        logDebug("Fallback camera started successfully");
        
        // Apply CSS to hide the built-in reticule
        setTimeout(() => {
          const scanRegionHighlight = document.getElementById('qr-reader__scan_region_highlight');
          if (scanRegionHighlight) {
            scanRegionHighlight.style.display = 'none';
          }
          
          // Remove any border from the video element
          const videoElements = document.querySelectorAll('#qr-reader video');
          videoElements.forEach(video => {
            video.style.border = 'none';
          });
        }, 500);
      }).catch(err => {
        logDebug("Error starting fallback camera: " + err);
        
        // Final fallback - try user facing camera
        logDebug("Trying user facing camera as last resort");
        html5QrCode.start(
          { facingMode: "user" },
          config,
          onScanSuccess,
          onScanFailure
        ).then(() => {
          // Camera started successfully
          if (cameraStartTimeout) {
            clearTimeout(cameraStartTimeout);
            cameraStartTimeout = null;
          }
          
          // Hide loading indicator
          cameraLoading.classList.add('hidden');
          
          logDebug("User facing camera started successfully");
          
          // Apply CSS to hide the built-in reticule
          setTimeout(() => {
            const scanRegionHighlight = document.getElementById('qr-reader__scan_region_highlight');
            if (scanRegionHighlight) {
              scanRegionHighlight.style.display = 'none';
            }
            
            // Remove any border from the video element
            const videoElements = document.querySelectorAll('#qr-reader video');
            videoElements.forEach(video => {
              video.style.border = 'none';
            });
          }, 500);
        }).catch(err => {
          logDebug("All camera options failed: " + err);
          showMessage("Could not start scanner. Please try manual entry.", true);
          stopScanning();
        });
      });
    }
    
    // Handle scan failure - just log for debugging
    function onScanFailure(error) {
      // We don't need to do anything on failure
      // console.log("QR scan error: " + error);
    }
    
    // Play beep sound
    function playBeep() {
      try {
        // Try to use AudioContext for better compatibility with silent mode
        if (window.AudioContext || window.webkitAudioContext) {
          // Create an AudioContext
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          // Create an oscillator for the beep sound
          const oscillator = audioContext.createOscillator();
          oscillator.type = 'sine'; // Sine wave ‚Äî a pure tone
          oscillator.frequency.setValueAtTime(1500, audioContext.currentTime); // Value in hertz
          
          // Create a gain node to control volume
          const gainNode = audioContext.createGain();
          gainNode.gain.setValueAtTime(0.25, audioContext.currentTime); // Increase volume
          
          // Connect oscillator to gain node and gain node to output
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          // Start and stop the oscillator to create a short beep
          oscillator.start();
          setTimeout(() => {
            oscillator.stop();
          }, 150); // Longer beep (150ms)
        }
      } catch (e) {
        logDebug("Error playing beep: " + e);
      }
    }
    
    // Trigger vibration
    function vibrate() {
      try {
        if (navigator.vibrate) {
          // Try a more noticeable vibration pattern (200ms on, 100ms off, 200ms on)
          navigator.vibrate([200, 100, 200]);
          logDebug("Vibration triggered");
        }
      } catch (e) {
        logDebug("Error vibrating: " + e);
      }
    }
    
    // Handle successful QR scan
    function onScanSuccess(decodedText) {
      // Log the raw scanned text for debugging
      logDebug(`Raw QR scan result: ${decodedText}`);
      
      // Show success flash
      flashOverlay.style.display = 'block';
      setTimeout(function() {
        flashOverlay.style.display = 'none';
      }, 500);
      
      // Play beep sound and vibrate
      playBeep();
      vibrate();
      
      // Process scan
      processScan(decodedText);
    }
    
    // Process scan data - UPDATED TO HANDLE QR CODE URLS
// Process scan data - UPDATED TO HANDLE "BibNumber, RunnerName" FORMAT
function processScan(decodedText) {
  // Log the raw scanned text for debugging
  logDebug(`Raw QR scan result: ${decodedText}`);
  
  // Extract the bib number from the scanned text
  let cleanBib;
  
  // Check if the text contains a comma (BibNumber, RunnerName format)
  if (decodedText.includes(',')) {
    // Split by comma and take the first part as the bib number
    const parts = decodedText.split(',');
    cleanBib = parts[0].trim().replace(/\D/g, '');
    logDebug(`Extracted bib from comma-separated format: ${cleanBib}`);
  } else {
    // If no comma, just clean the whole text
    cleanBib = decodedText.toString().replace(/\D/g, '');
    logDebug(`No comma found, cleaned bib: ${cleanBib}`);
  }
  
  // If no bib number could be extracted, show error
  if (!cleanBib) {
    showMessage(`Could not extract bib number from scan`, true);
    return;
  }
  
  logDebug(`Processing scan for bib: ${cleanBib}`);
  
  // Find runner in our loaded data
  const runnerName = runnersData[cleanBib];
  
  if (!runnerName) {
    showMessage(`No runner found with bib ${cleanBib}`, true);
    return;
  }
  
  // Check if we should process this scan (not a duplicate or is newer)
  if (!shouldProcessScan(cleanBib, checkpoint)) {
    showMessage(`Already recorded: ${runnerName} (${cleanBib})`, false);
    return;
  }
  
  const scanData = {
    timestamp: new Date().toISOString(),
    bib: cleanBib,
    name: runnerName,
    checkpoint: checkpoint
  };
  
  // Mark as processed to prevent duplicates
  markScanAsProcessed(cleanBib, checkpoint);
  
  // Add to recent scans
  storeRecentScan(scanData);
  
  if (isOnline) {
    submitScanToSheet(scanData)
      .then(function(success) {
        if (success) {
          // Mark as uploaded to prevent duplicates
          markScanAsUploaded(scanData);
          showMessage(`Recorded: ${runnerName} (${cleanBib})`);
        } else {
          showMessage('Error submitting scan. Storing offline.', true);
          storeScanOffline(scanData);
        }
      })
      .catch(function(error) {
        logDebug('Error submitting scan: ' + error);
        showMessage('Error submitting scan. Storing offline.', true);
        storeScanOffline(scanData);
      });
  } else {
    storeScanOffline(scanData);
    showMessage(`Stored offline: ${runnerName} (${cleanBib})`);
  }
}
    
    // Check if scan is a duplicate and if it's the most recent
    function shouldProcessScan(bib, checkpoint) {
      const key = `${bib}-${checkpoint}`;
      
      // If we've never seen this bib+checkpoint, definitely process it
      if (!processedScans[key]) {
        return true;
      }
      
      // If we've seen it before, check if this is a newer scan
      const now = Date.now();
      const lastScanTime = scanTimestamps[key] || 0;
      
      // Only process if it's been at least 5 seconds since the last scan
      // This prevents accidental double-scans
      return (now - lastScanTime) > 5000;
    }
    
    // Mark scan as processed
    function markScanAsProcessed(bib, checkpoint) {
      const key = `${bib}-${checkpoint}`;
      processedScans[key] = true;
      scanTimestamps[key] = Date.now();
      saveProcessedScans();
      saveScanTimestamps();
    }
    
    // Mark scan as uploaded to prevent duplicates
    function markScanAsUploaded(scanData) {
      const key = `${scanData.bib}-${scanData.checkpoint}`;
      uploadedScans[key] = true;
      saveUploadedScans();
    }
    
    // Check if scan has already been uploaded
    function hasBeenUploaded(scanData) {
      const key = `${scanData.bib}-${scanData.checkpoint}`;
      return uploadedScans[key] === true;
    }
    
    // Store a recent scan
    function storeRecentScan(scanData) {
      try {
        // Add to memory first
        if (recentScans.length >= 10) {
          recentScans.pop(); // Remove the oldest scan
        }
        recentScans.unshift(scanData); // Add new scan at the beginning
        updateRecentScansUI();
        
        // Store in localStorage
        localStorage.setItem('recentScans', JSON.stringify(recentScans));
      } catch (error) {
        logDebug('Error storing recent scan: ' + error);
      }
    }
    
    // Store scan offline
    function storeScanOffline(scanData) {
      try {
        // Check if we already have a pending upload for this bib+checkpoint
        const existingIndex = pendingUploads.findIndex(
          scan => scan.bib === scanData.bib && scan.checkpoint === scanData.checkpoint
        );
        
        if (existingIndex >= 0) {
          // Replace the existing entry with the newer one
          pendingUploads[existingIndex] = scanData;
        } else {
          // Add to memory
          pendingUploads.push(scanData);
        }
        
        updatePendingUploadsUI();
        
        // Store in localStorage
        localStorage.setItem('pendingUploads', JSON.stringify(pendingUploads));
        logDebug(`Stored scan offline: ${scanData.bib} - ${scanData.name}`);
      } catch (error) {
        logDebug('Error storing scan offline: ' + error);
      }
    }
    
// Submit scan to Google Sheet using JSONP
function submitScanToSheet(scanData) {
  return new Promise(function(resolve, reject) {
    // Assuming logDebug and APPS_SCRIPT_URL are defined elsewhere or will be defined before this function is called.
    // For example:
    // const logDebug = console.log; // Or a more sophisticated logging function
    // const APPS_SCRIPT_URL = 'YOUR_APPS_SCRIPT_URL';

    logDebug(`Submitting scan to sheet: ${scanData.bib} - ${scanData.name} at ${scanData.checkpoint}`);
    
    // Create a unique callback name
    const callbackName = 'jsonpCallback_' + Date.now();
    
    // Define the callback function
    window[callbackName] = function(response) {
      // Clean up
      document.body.removeChild(script);
      delete window[callbackName];
      
      logDebug('JSONP response received');
      resolve(true);
    };
    
    // Create the data to send
    const data = {
      timestamp: scanData.timestamp,
      bibNumber: scanData.bib,
      runnerName: scanData.name,
      checkpoint: scanData.checkpoint,
      replaceExisting: true
    };
    
    // Create the script element
    const script = document.createElement('script');
    script.src = `${APPS_SCRIPT_URL}?action=recordScan&data=${encodeURIComponent(JSON.stringify(data))}&callback=${callbackName}&nocache=${Date.now()}`;
    
    // Handle errors
    script.onerror = function() {
      // Clean up
      delete window[callbackName];
      document.body.removeChild(script);
      
      logDebug('Network error when submitting scan');
      // Even with network errors, we'll assume success after a timeout
      // This is because Google Apps Script often processes the request successfully
      // even if the browser reports a CORS error
    };
    
    // Add the script to the document
    document.body.appendChild(script);
    
    // Set a timeout to resolve as success after 5 seconds
    setTimeout(() => {
      if (window[callbackName]) {
        delete window[callbackName];
        logDebug('Assuming success due to timeout');
        resolve(true);
      }
    }, 5000);
  });
}

    
// Upload pending scans
function uploadPendingScans(forceUpload = false) {
  if (pendingUploads.length === 0 || (!isOnline && !forceUpload) || isUploadingPendingScans) return;
  
  isUploadingPendingScans = true;
  logDebug(`Attempting to upload ${pendingUploads.length} pending scans`);
  
  // Process each scan one at a time
  uploadNextScan(0);
  
  function uploadNextScan(index) {
    if (index >= pendingUploads.length) {
      // All done
      logDebug('Finished uploading pending scans');
      isUploadingPendingScans = false;
      return;
    }
    
    const scanData = pendingUploads[index];
    logDebug(`Uploading pending scan ${index + 1}/${pendingUploads.length}: ${scanData.bib} at ${scanData.checkpoint}`);
    
    submitScanToSheet(scanData)
      .then(success => {
        // Always remove from pending uploads and assume success
        // This is because with CORS, we can't reliably determine if the upload failed
        logDebug(`Processed scan: ${scanData.bib} at ${scanData.checkpoint}`);
        
        // Remove this scan from pendingUploads
        pendingUploads.splice(index, 1);
        
        // Update localStorage
        localStorage.setItem('pendingUploads', JSON.stringify(pendingUploads));
        updatePendingUploadsUI();
        
        // Continue with the next scan (same index since we removed one)
        setTimeout(() => uploadNextScan(index), 1000);
      })
      .catch(error => {
        logDebug(`Error uploading scan: ${error}`);
        // Move to the next scan
        setTimeout(() => uploadNextScan(index + 1), 1000);
      });
  }
}
    
    
    // Handle manual bib submission
    manualSubmitButton.addEventListener('click', function() {
      const bib = bibInput.value.trim();
      
      if (!bib) {
        showMessage('Please enter a bib number', true);
        return;
      }
      
      // Find runner in our loaded data
      const runnerName = runnersData[bib];
      
      if (!runnerName) {
        showMessage(`No runner found with bib ${bib}`, true);
        return;
      }
      
      // Check if we should process this scan (not a duplicate or is newer)
      if (!shouldProcessScan(bib, checkpoint)) {
        showMessage(`Already recorded: ${runnerName} (${bib})`, false);
        bibInput.value = '';
        return;
      }
      
      const scanData = {
        timestamp: new Date().toISOString(),
        bib: bib,
        name: runnerName,
        checkpoint: checkpoint
      };
      
      // Mark as processed to prevent duplicates
      markScanAsProcessed(bib, checkpoint);
      
      // Play beep sound and vibrate
      playBeep();
      vibrate();
      
      // Add to recent scans
      storeRecentScan(scanData);
      
      if (isOnline) {
        submitScanToSheet(scanData)
          .then(function(success) {
            if (success) {
              // Mark as uploaded to prevent duplicates
              markScanAsUploaded(scanData);
              showMessage(`Recorded: ${runnerName} (${bib})`);
              // Clear form
              bibInput.value = '';
            } else {
              showMessage('Error submitting entry. Storing offline.', true);
              storeScanOffline(scanData);
              // Still clear the form
              bibInput.value = '';
            }
          })
          .catch(function(error) {
            logDebug('Error submitting manual entry: ' + error);
            showMessage('Error submitting entry. Storing offline.', true);
            storeScanOffline(scanData);
            // Still clear the form
            bibInput.value = '';
          });
      } else {
        storeScanOffline(scanData);
        showMessage(`Stored offline: ${runnerName} (${bib})`);
        // Clear form
        bibInput.value = '';
      }
    });
    
    // Show message
    function showMessage(text, isError = false) {
      messageDisplay.textContent = text;
      messageDisplay.classList.remove('hidden');
      
      if (isError) {
        messageDisplay.classList.remove('success-message');
        messageDisplay.classList.add('error-message');
      } else {
        messageDisplay.classList.remove('error-message');
        messageDisplay.classList.add('success-message');
      }
      
      // Hide message after 3 seconds
      setTimeout(function() {
        messageDisplay.classList.add('hidden');
      }, 3000);
    }
    
    // Initialize the app
    init();
  });
</script>
</body>
</html>
