<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tiger Claw Timing System</title>
  <style>
    /* Basic styling */
    * {
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    
    #tiger-claw-app {
      max-width: 500px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9f9f9;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    .app-header {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .app-header h1 {
      color: #1e7e34;
      margin-bottom: 5px;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    select, input, button {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 16px;
    }
    
    button {
      background-color: #28a745;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: bold;
      margin-top: 10px;
      padding: 12px;
    }
    
    button:hover {
      background-color: #218838;
    }
    
    button:disabled {
      background-color: #6c757d;
      cursor: not-allowed;
    }
    
    .error-message {
      color: #dc3545;
      margin-top: 5px;
      font-size: 14px;
    }
    
    .success-message {
      color: #28a745;
      margin-top: 5px;
      font-size: 14px;
    }
    
    .connection-status {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
      font-size: 14px;
    }
    
    .status-connected {
      color: #28a745;
    }
    
    .status-disconnected {
      color: #dc3545;
    }
    
    .status-icon {
      margin-right: 5px;
    }
    
    .hidden {
      display: none;
    }
    
    .scanner-container {
      position: relative;
      margin: 10px 0;
      /* Make scanner more prominent and higher in the view */
      max-width: 350px;
      margin-left: auto;
      margin-right: auto;
    }
    
    /* QR reader container - let it use natural aspect ratio */
    #qr-reader {
      width: 100% !important;
      border: none !important;
      box-shadow: none !important;
      position: relative;
      overflow: hidden;
      border-radius: 8px;
    }

    /* Fix for black rectangle */
#qr-reader__dashboard_section_csr {
  background: transparent !important;
}

#qr-reader__scan_region {
  background: transparent !important;
}

#qr-reader video {
  max-height: 300px !important;
  object-fit: cover !important;
}
    
    /* Targeting overlay - adapt to the actual camera view */
    .targeting-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }
    
    .targeting-overlay::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 70%;
      height: 70%;
      border: 2px dashed #28a745;
      border-radius: 8px;
    }
    
    .targeting-overlay::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid #28a745;
      border-radius: 50%;
    }
    
    .flash-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(40, 167, 69, 0.7);
      z-index: 10;
      display: none;
      border-radius: 8px;
    }
    
    .pending-uploads {
      background-color: #fff3cd;
      color: #856404;
      padding: 10px;
      border-radius: 5px;
      margin-top: 15px;
      font-size: 14px;
    }
    
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: #28a745;
      animation: spin 1s ease-in-out infinite;
      margin-right: 10px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* QR Scanner customizations */
    #qr-reader__scan_region {
      min-height: 300px;
    }
    
    /* Hide unnecessary elements */
    #qr-reader__dashboard_section_swaplink,
    #qr-reader__dashboard_section_csr button {
      display: none !important;
    }
    
    #qr-reader__status_span {
      background-color: #f0fdf4 !important;
      color: #166534 !important;
    }
    
    #qr-reader__camera_selection {
      display: none !important;
    }
    
    #qr-reader__dashboard_section_csr {
      padding: 0 !important;
    }
    
    /* Hide file selection */
    #qr-reader__filescan_input {
      display: none !important;
    }
    
    #qr-reader__filescan_input + span {
      display: none !important;
    }
    
    /* Recent scans list */
    .recent-scans {
      margin-top: 20px;
      border-top: 1px solid #ddd;
      padding-top: 10px;
    }
    
    .recent-scans h3 {
      margin-top: 0;
      font-size: 16px;
    }
    
    .scan-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
    }
    
    .scan-item:last-child {
      border-bottom: none;
    }
    
    .scan-bib {
      font-weight: bold;
    }
    
    .scan-time {
      color: #666;
      font-size: 14px;
    }
    
    /* Debug panel */
    .debug-panel {
      margin-top: 20px;
      padding: 10px;
      background-color: #f8f9fa;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 12px;
    }
    
    .debug-panel h4 {
      margin-top: 0;
      margin-bottom: 5px;
    }
    
    .debug-panel pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-all;
    }
    
    /* Native camera fallback */
    #native-camera-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 20px 0;
    }
    
    #native-camera-video {
      width: 100%;
      max-width: 350px;
      border-radius: 8px;
      background-color: #000;
      object-fit: cover;
    }
    
    #native-camera-canvas {
      display: none;
    }
    
    /* Camera instructions */
    .camera-instructions {
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
      color: #666;
    }
    
    /* Manual entry section - make it more compact when scanner is active */
    .scanner-active .manual-entry-section {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #ddd;
    }
    
    .scanner-active .manual-entry-section h2 {
      font-size: 16px;
      margin-top: 0;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div id="tiger-claw-app">
    <!-- Loading Screen -->
    <div id="loading-screen">
      <div class="app-header">
        <h1>TIGER CLAW TIMING SYSTEM</h1>
        <p>Loading runner data...</p>
        <div class="loading-spinner"></div>
      </div>
    </div>
    
    <!-- Login Screen -->
    <div id="login-screen" class="hidden">
      <div class="app-header">
        <h1>TIGER CLAW TIMING SYSTEM</h1>
      </div>
      
      <div class="form-group">
        <label for="checkpoint-select">Select Checkpoint</label>
        <select id="checkpoint-select">
          <option value="">Select checkpoint</option>
          <option value="GREEN CHECKPOINT">GREEN CHECKPOINT</option>
          <option value="PINK LOOP TOP">PINK LOOP TOP</option>
          <option value="PINK LOOP BOTTOM">PINK LOOP BOTTOM</option>
          <option value="YELLOW LOOP TOP">YELLOW LOOP TOP</option>
          <option value="YELLOW LOOP BOTTOM">YELLOW LOOP BOTTOM</option>
          <option value="WHITE LOOP TOP">WHITE LOOP TOP</option>
          <option value="WHITE LOOP BOTTOM">WHITE LOOP BOTTOM</option>
          <option value="RED CHECKPOINT">RED CHECKPOINT</option>
          <option value="FINISHLINE">FINISHLINE</option>
        </select>
      </div>
      
      <div class="form-group">
        <label for="password-input">Password</label>
        <input type="password" id="password-input" placeholder="Enter password">
        <div id="login-error" class="error-message hidden"></div>
      </div>
      
      <button id="login-button">Login</button>
      
      <!-- Debug panel toggle -->
      <div style="margin-top: 20px; text-align: center;">
        <button id="toggle-debug" style="background-color: #6c757d; width: auto; font-size: 12px; padding: 5px 10px;">Show Debug Panel</button>
      </div>
    </div>
    
    <!-- Scanner Screen -->
    <div id="scanner-screen" class="hidden">
      <div class="app-header">
        <h1>TIGER CLAW TIMING</h1>
        <div id="checkpoint-display" style="font-weight: bold; font-size: 18px; margin: 10px 0;"></div>
        <div id="connection-status" class="connection-status">
          <span id="status-icon" class="status-icon">●</span>
          <span id="status-text">CHECKING CONNECTION...</span>
        </div>
      </div>
      
      <button id="scan-button" class="scan-button">START SCANNING</button>
      
      <!-- HTML5QrCode scanner container -->
      <div id="scanner-container" class="scanner-container hidden">
        <div id="qr-reader"></div>
        <div class="targeting-overlay"></div>
        <div id="flash-overlay" class="flash-overlay"></div>
        <div class="camera-instructions">Align QR code within the target</div>
      </div>
      
      <!-- Native camera fallback -->
      <div id="native-camera-container" class="hidden">
        <video id="native-camera-video" autoplay playsinline></video>
        <canvas id="native-camera-canvas"></canvas>
        <div class="camera-instructions">Align QR code within the target</div>
      </div>
      
      <div id="message" class="success-message hidden"></div>
      
      <div class="form-group manual-entry-section" style="margin-top: 20px;">
        <h2>Manual Entry</h2>
        <div class="form-group">
          <label for="bib-input">Bib Number (required)</label>
          <input type="tel" id="bib-input" inputmode="numeric" pattern="[0-9]*" placeholder="Enter bib number">
        </div>
        
        <button id="manual-submit-button">SUBMIT</button>
      </div>
      
      <div id="pending-uploads" class="pending-uploads hidden"></div>
      
      <div id="recent-scans" class="recent-scans">
        <h3>Recent Scans</h3>
        <div id="scans-list"></div>
      </div>
      
      <button id="logout-button" style="background-color: #6c757d; margin-top: 20px;">Logout</button>
      
      <!-- Debug panel (hidden by default) -->
      <div id="debug-panel" class="debug-panel hidden">
        <h4>Debug Info</h4>
        <pre id="debug-info"></pre>
        <button id="force-upload" style="background-color: #6c757d; margin-top: 10px; font-size: 12px;">Force Upload Pending Scans</button>
        <button id="clear-data" style="background-color: #dc3545; margin-top: 10px; font-size: 12px;">Clear All Data</button>
      </div>
    </div>
  </div>

  <!-- Include the HTML5 QR Code Scanner library directly in the HTML -->
  <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
  
  <script>
    // Main application code
    document.addEventListener('DOMContentLoaded', function() {
      // DOM Elements
      const loadingScreen = document.getElementById('loading-screen');
      const loginScreen = document.getElementById('login-screen');
      const scannerScreen = document.getElementById('scanner-screen');
      const checkpointSelect = document.getElementById('checkpoint-select');
      const passwordInput = document.getElementById('password-input');
      const loginButton = document.getElementById('login-button');
      const loginError = document.getElementById('login-error');
      const checkpointDisplay = document.getElementById('checkpoint-display');
      const scanButton = document.getElementById('scan-button');
      const scannerContainer = document.getElementById('scanner-container');
      const nativeCameraContainer = document.getElementById('native-camera-container');
      const nativeCameraVideo = document.getElementById('native-camera-video');
      const nativeCameraCanvas = document.getElementById('native-camera-canvas');
      const flashOverlay = document.getElementById('flash-overlay');
      const messageDisplay = document.getElementById('message');
      const bibInput = document.getElementById('bib-input');
      const manualSubmitButton = document.getElementById('manual-submit-button');
      const logoutButton = document.getElementById('logout-button');
      const connectionStatus = document.getElementById('connection-status');
      const statusIcon = document.getElementById('status-icon');
      const statusText = document.getElementById('status-text');
      const pendingUploadsContainer = document.getElementById('pending-uploads');
      const scansList = document.getElementById('scans-list');
      const debugPanel = document.getElementById('debug-panel');
      const debugInfo = document.getElementById('debug-info');
      const toggleDebugBtn = document.getElementById('toggle-debug');
      const forceUploadBtn = document.getElementById('force-upload');
      const clearDataBtn = document.getElementById('clear-data');
      
      // Application state
      let isScanning = false;
      let isOnline = navigator.onLine;
      let html5QrCode = null;
      let checkpoint = '';
      let pendingUploads = [];
      let runnersData = {}; // Will store all runners data
      let recentScans = []; // Store recent scans for display
      let lastUploadAttempt = 0; // Track last upload attempt time
      let debugMode = false; // Debug mode flag
      let useNativeCamera = false; // Whether to use native camera API as fallback
      let nativeCameraStream = null; // Store the camera stream
      let processedScans = {}; // Track processed scans to prevent duplicates
      let scanTimestamps = {}; // Track timestamps of scans to ensure we only keep the most recent
      
      // Constants
      const CORRECT_PASSWORD = "threeloops";
      const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbx0xQRfKFQY2Y0vU0oGwqxAXW8t3vLMx2VbGZ010BpJ5tz9_hb_B0bP8pm8OZhLPG22/exec";
      
      // Toggle debug panel
      toggleDebugBtn.addEventListener('click', function() {
        debugMode = !debugMode;
        if (debugMode) {
          debugPanel.classList.remove('hidden');
          toggleDebugBtn.textContent = 'Hide Debug Panel';
        } else {
          debugPanel.classList.add('hidden');
          toggleDebugBtn.textContent = 'Show Debug Panel';
        }
      });
      
      // Force upload pending scans
      forceUploadBtn.addEventListener('click', function() {
        logDebug('Manually forcing upload of pending scans');
        uploadPendingScans(true);
      });
      
      // Clear all data
      clearDataBtn.addEventListener('click', function() {
        if (confirm('Are you sure you want to clear all data? This will delete all stored runner data and scans.')) {
          clearAllData();
        }
      });
      
      // Clear all data from localStorage
      function clearAllData() {
        try {
          localStorage.removeItem('pendingUploads');
          localStorage.removeItem('recentScans');
          localStorage.removeItem('runnersData');
          localStorage.removeItem('processedScans');
          localStorage.removeItem('scanTimestamps');
          
          pendingUploads = [];
          recentScans = [];
          runnersData = {};
          processedScans = {};
          scanTimestamps = {};
          
          updatePendingUploadsUI();
          updateRecentScansUI();
          
          logDebug('All data cleared successfully');
          showMessage('All data cleared successfully');
        } catch (error) {
          logDebug('Error clearing data: ' + error);
          showMessage('Error clearing data', true);
        }
      }
      
      // Log to debug panel
      function logDebug(message) {
        const timestamp = new Date().toLocaleTimeString();
        if (debugInfo) {
          debugInfo.textContent = `[${timestamp}] ${message}\n` + debugInfo.textContent;
        }
        console.log(message);
      }
      
      // Initialize the application
      function init() {
        // Load data from localStorage
        loadPendingScans();
        loadRecentScans();
        loadProcessedScans();
        loadScanTimestamps();
        
        // Fetch runner data
        fetchRunnerData();
        
        // Set up online/offline event listeners
        window.addEventListener('online', handleOnlineStatusChange);
        window.addEventListener('offline', handleOnlineStatusChange);
      }
      
      // Load processed scans from localStorage
      function loadProcessedScans() {
        try {
          const storedProcessedScans = localStorage.getItem('processedScans');
          if (storedProcessedScans) {
            processedScans = JSON.parse(storedProcessedScans);
            logDebug(`Loaded processed scans tracking data from localStorage`);
          }
        } catch (error) {
          logDebug('Error loading processed scans: ' + error);
          processedScans = {};
        }
      }
      
      // Load scan timestamps from localStorage
      function loadScanTimestamps() {
        try {
          const storedTimestamps = localStorage.getItem('scanTimestamps');
          if (storedTimestamps) {
            scanTimestamps = JSON.parse(storedTimestamps);
            logDebug(`Loaded scan timestamps from localStorage`);
          }
        } catch (error) {
          logDebug('Error loading scan timestamps: ' + error);
          scanTimestamps = {};
        }
      }
      
      // Save processed scans to localStorage
      function saveProcessedScans() {
        try {
          localStorage.setItem('processedScans', JSON.stringify(processedScans));
        } catch (error) {
          logDebug('Error saving processed scans: ' + error);
        }
      }
      
      // Save scan timestamps to localStorage
      function saveScanTimestamps() {
        try {
          localStorage.setItem('scanTimestamps', JSON.stringify(scanTimestamps));
        } catch (error) {
          logDebug('Error saving scan timestamps: ' + error);
        }
      }
      
      // Handle online/offline status changes
      function handleOnlineStatusChange() {
        isOnline = navigator.onLine;
        updateConnectionStatus();
        
        // If we're back online and have offline entries, try to sync them
        if (isOnline && pendingUploads.length > 0) {
          uploadPendingScans();
        }
      }
      
      // Load pending scans from localStorage
      function loadPendingScans() {
        try {
          const storedUploads = localStorage.getItem('pendingUploads');
          if (storedUploads) {
            pendingUploads = JSON.parse(storedUploads);
            logDebug(`Loaded ${pendingUploads.length} pending scans from localStorage`);
            updatePendingUploadsUI();
          }
        } catch (error) {
          logDebug('Error loading pending scans: ' + error);
          pendingUploads = [];
        }
      }
      
      // Load recent scans from localStorage
      function loadRecentScans() {
        try {
          const storedScans = localStorage.getItem('recentScans');
          if (storedScans) {
            recentScans = JSON.parse(storedScans);
            logDebug(`Loaded ${recentScans.length} recent scans from localStorage`);
            updateRecentScansUI();
          }
        } catch (error) {
          logDebug('Error loading recent scans: ' + error);
          recentScans = [];
        }
      }
      
      // Fetch runner data from Google Sheets
      function fetchRunnerData() {
        logDebug('Fetching runner data from Google Sheets...');
        
        // Try to load from localStorage first
        try {
          const storedData = localStorage.getItem('runnersData');
          if (storedData) {
            const parsedData = JSON.parse(storedData);
            if (parsedData && Object.keys(parsedData).length > 0) {
              runnersData = parsedData;
              logDebug(`Loaded ${Object.keys(runnersData).length} runners from localStorage`);
              loadingScreen.classList.add('hidden');
              checkLoginStatus();
              return;
            }
          }
        } catch (error) {
          logDebug('Error loading runners data from localStorage: ' + error);
        }
        
        // Fetch from Google Sheets
        fetch(`${APPS_SCRIPT_URL}?action=getRunnerData`)
          .then(response => response.text())
          .then(text => {
            try {
              // Handle JSONP-like response
              const jsonStart = text.indexOf('{');
              const jsonEnd = text.lastIndexOf('}') + 1;
              if (jsonStart >= 0 && jsonEnd > 0) {
                const jsonString = text.substring(jsonStart, jsonEnd);
                const data = JSON.parse(jsonString);
                
                if (data.success && data.data) {
                  const runnerMap = {};
                  data.data.forEach(runner => {
                    runnerMap[runner.bibNumber] = runner.name;
                  });
                  runnersData = runnerMap;
                  
                  // Store in localStorage for future use
                  localStorage.setItem('runnersData', JSON.stringify(runnersData));
                  
                  logDebug(`Loaded ${Object.keys(runnersData).length} runners from Google Sheets`);
                } else {
                  logDebug('Invalid or empty runners data format from API');
                }
              } else {
                logDebug('Invalid response from server');
              }
            } catch (error) {
              logDebug('Error parsing runner data: ' + error);
            }
            
            loadingScreen.classList.add('hidden');
            checkLoginStatus();
          })
          .catch(error => {
            logDebug('Error fetching runner data: ' + error);
            loadingScreen.classList.add('hidden');
            checkLoginStatus();
          });
      }
      
      // Update recent scans UI
      function updateRecentScansUI() {
        scansList.innerHTML = '';
        
        if (recentScans.length === 0) {
          scansList.innerHTML = '<p>No scans yet</p>';
          return;
        }
        
        recentScans.forEach(scan => {
          const scanTime = new Date(scan.timestamp).toLocaleTimeString();
          const scanItem = document.createElement('div');
          scanItem.className = 'scan-item';
          scanItem.innerHTML = `
            <div>
              <span class="scan-bib">#${scan.bib}</span> - ${scan.name}
            </div>
            <div class="scan-time">${scanTime}</div>
          `;
          scansList.appendChild(scanItem);
        });
      }
      
      // Update pending uploads UI
      function updatePendingUploadsUI() {
        if (pendingUploads.length > 0) {
          pendingUploadsContainer.classList.remove('hidden');
          pendingUploadsContainer.textContent = `${pendingUploads.length} scan${pendingUploads.length > 1 ? 's' : ''} pending upload. Data will be uploaded automatically when connection is restored.`;
        } else {
          pendingUploadsContainer.classList.add('hidden');
        }
      }
      
      // Update connection status UI
      function updateConnectionStatus() {
        if (isOnline) {
          statusIcon.classList.add('status-connected');
          statusIcon.classList.remove('status-disconnected');
          statusText.textContent = 'CONNECTED';
          statusText.classList.add('status-connected');
          statusText.classList.remove('status-disconnected');
          
          // Try to upload pending scans
          if (pendingUploads.length > 0) {
            // Only attempt upload if it's been more than 5 seconds since last attempt
            const now = Date.now();
            if (now - lastUploadAttempt > 5000) {
              lastUploadAttempt = now;
              uploadPendingScans();
            }
          }
        } else {
          statusIcon.classList.add('status-disconnected');
          statusIcon.classList.remove('status-connected');
          statusText.textContent = 'NO SERVICE';
          statusText.classList.add('status-disconnected');
          statusText.classList.remove('status-connected');
        }
      }
      
      // Check if user is already logged in
      function checkLoginStatus() {
        const savedCheckpoint = localStorage.getItem('tigerClawCheckpoint');
        if (savedCheckpoint) {
          checkpoint = savedCheckpoint;
          showScannerScreen();
        } else {
          loginScreen.classList.remove('hidden');
        }
      }
      
      // Show scanner screen
      function showScannerScreen() {
        loginScreen.classList.add('hidden');
        loadingScreen.classList.add('hidden');
        scannerScreen.classList.remove('hidden');
        checkpointDisplay.textContent = checkpoint;
        updateConnectionStatus();
      }
      
      // Show login screen
      function showLoginScreen() {
        scannerScreen.classList.add('hidden');
        loadingScreen.classList.add('hidden');
        loginScreen.classList.remove('hidden');
        
        // Clear form
        checkpointSelect.value = '';
        passwordInput.value = '';
        loginError.classList.add('hidden');
      }
      
      // Handle login
      loginButton.addEventListener('click', function() {
        const selectedCheckpoint = checkpointSelect.value;
        const password = passwordInput.value;
        
        if (!selectedCheckpoint) {
          loginError.textContent = 'Please select a checkpoint';
          loginError.classList.remove('hidden');
          return;
        }
        
        if (password !== CORRECT_PASSWORD) {
          loginError.textContent = 'Incorrect password';
          loginError.classList.remove('hidden');
          return;
        }
        
        // Save checkpoint and show scanner screen
        checkpoint = selectedCheckpoint;
        localStorage.setItem('tigerClawCheckpoint', checkpoint);
        showScannerScreen();
      });
      
      // Handle logout
      logoutButton.addEventListener('click', function() {
        // Stop scanner if running
        stopScanning();
        
        localStorage.removeItem('tigerClawCheckpoint');
        showLoginScreen();
      });
      
      // Stop scanning (both HTML5QrCode and native camera)
      function stopScanning() {
        if (isScanning) {
          if (html5QrCode) {
            try {
              html5QrCode.stop().catch(err => {
                logDebug("Error stopping HTML5QrCode scanner: " + err);
              });
            } catch (e) {
              logDebug("Error stopping HTML5QrCode scanner: " + e);
            }
          }
          
          if (nativeCameraStream) {
            try {
              nativeCameraStream.getTracks().forEach(track => track.stop());
              nativeCameraStream = null;
            } catch (e) {
              logDebug("Error stopping native camera: " + e);
            }
          }
          
          isScanning = false;
          scannerContainer.classList.add('hidden');
          nativeCameraContainer.classList.add('hidden');
          scanButton.textContent = 'START SCANNING';
          scanButton.style.backgroundColor = '#28a745';
          
          // Remove scanner-active class from scanner screen
          scannerScreen.classList.remove('scanner-active');
        }
      }
      
      // Toggle scanner
      scanButton.addEventListener('click', function() {
        if (isScanning) {
          stopScanning();
        } else {
          // Start scanning
          isScanning = true;
          scanButton.textContent = 'STOP SCANNING';
          scanButton.style.backgroundColor = '#dc3545';
          
          // Add scanner-active class to scanner screen
          scannerScreen.classList.add('scanner-active');
          
          // Start the scanner
          startScanner();
        }
      });
      
      // Start QR scanner with back camera - SIMPLIFIED VERSION
      function startScanner() {
        try {
          // Make sure the scanner container is visible
          scannerContainer.classList.remove('hidden');
          nativeCameraContainer.classList.add('hidden');
          
          // Create a new instance of the QR scanner
          html5QrCode = new Html5Qrcode("qr-reader");
          
          // Simple configuration that works reliably
          // Removed fixed aspect ratio to let the camera use its natural ratio
          const config = {
            fps: 10,
            qrbox: { width: 250, height: 250 }
          };
          
          // Try to get the back camera
          Html5Qrcode.getCameras().then(devices => {
            if (devices && devices.length) {
              // Prefer back camera (usually the last in the list)
              const cameraId = devices[devices.length - 1].id;
              
              html5QrCode.start(
                cameraId, 
                config, 
                onScanSuccess, 
                onScanFailure
              ).catch(err => {
                logDebug("Error starting scanner with selected camera: " + err);
                // Try with default environment facing mode
                html5QrCode.start(
                  { facingMode: "environment" },
                  config,
                  onScanSuccess,
                  onScanFailure
                ).catch(err => {
                  logDebug("Error starting scanner with environment mode: " + err);
                  showMessage("Could not start scanner. Please try manual entry.", true);
                  stopScanning();
                });
              });
            } else {
              // No cameras found, try with default environment facing mode
              html5QrCode.start(
                { facingMode: "environment" },
                config,
                onScanSuccess,
                onScanFailure
              ).catch(err => {
                logDebug("Error starting scanner: " + err);
                showMessage("Could not start scanner. Please try manual entry.", true);
                stopScanning();
              });
            }
          }).catch(err => {
            logDebug("Error getting cameras: " + err);
            // Try with default environment facing mode
            html5QrCode.start(
              { facingMode: "environment" },
              config,
              onScanSuccess,
              onScanFailure
            ).catch(err => {
              logDebug("Error starting scanner: " + err);
              showMessage("Could not start scanner. Please try manual entry.", true);
              stopScanning();
            });
          });
        } catch (error) {
          logDebug("Error initializing scanner: " + error);
          showMessage("Error initializing scanner. Please try manual entry.", true);
          stopScanning();
        }
      }
      
      // Handle scan failure - just log for debugging
      function onScanFailure(error) {
        // We don't need to do anything on failure
        // console.log("QR scan error: " + error);
      }
      
      // Play beep sound
      function playBeep() {
        try {
          // Try to use AudioContext for better compatibility with silent mode
          if (window.AudioContext || window.webkitAudioContext) {
            // Create an AudioContext
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create an oscillator for the beep sound
            const oscillator = audioContext.createOscillator();
            oscillator.type = 'sine'; // Sine wave — a pure tone
            oscillator.frequency.setValueAtTime(1500, audioContext.currentTime); // Value in hertz
            
            // Create a gain node to control volume
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.25, audioContext.currentTime); // Increase volume
            
            // Connect oscillator to gain node and gain node to output
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Start and stop the oscillator to create a short beep
            oscillator.start();
            setTimeout(() => {
              oscillator.stop();
            }, 150); // Longer beep (150ms)
          }
        } catch (e) {
          logDebug("Error playing beep: " + e);
        }
      }
      
      // Trigger vibration
      function vibrate() {
        try {
          if (navigator.vibrate) {
            // Try a more noticeable vibration pattern (200ms on, 100ms off, 200ms on)
            navigator.vibrate([200, 100, 200]);
            logDebug("Vibration triggered");
          }
        } catch (e) {
          logDebug("Error vibrating: " + e);
        }
      }
      
      // Handle successful QR scan
      function onScanSuccess(decodedText) {
        // Show success flash
        flashOverlay.style.display = 'block';
        setTimeout(function() {
          flashOverlay.style.display = 'none';
        }, 500);
        
        // Play beep sound and vibrate
        playBeep();
        vibrate();
        
        // Process scan
        processScan(decodedText);
      }
      
      // Check if scan is a duplicate and if it's the most recent
      function shouldProcessScan(bib, checkpoint) {
        const key = `${bib}-${checkpoint}`;
        
        // If we've never seen this bib+checkpoint, definitely process it
        if (!processedScans[key]) {
          return true;
        }
        
        // If we've seen it before, check if this is a newer scan
        const now = Date.now();
        const lastScanTime = scanTimestamps[key] || 0;
        
        // Only process if it's been at least 5 seconds since the last scan
        // This prevents accidental double-scans
        return (now - lastScanTime) > 5000;
      }
      
      // Mark scan as processed
      function markScanAsProcessed(bib, checkpoint) {
        const key = `${bib}-${checkpoint}`;
        processedScans[key] = true;
        scanTimestamps[key] = Date.now();
        saveProcessedScans();
        saveScanTimestamps();
      }
      
      // Process scan data
      function processScan(bib) {
        // Clean the bib number (remove any non-numeric characters)
        const cleanBib = bib.toString().replace(/\D/g, '');
        
        logDebug(`Processing scan for bib: ${cleanBib}`);
        
        // Find runner in our loaded data
        const runnerName = runnersData[cleanBib];
        
        if (!runnerName) {
          showMessage(`No runner found with bib ${cleanBib}`, true);
          return;
        }
        
        // Check if we should process this scan (not a duplicate or is newer)
        if (!shouldProcessScan(cleanBib, checkpoint)) {
          showMessage(`Already recorded: ${runnerName} (${cleanBib})`, false);
          return;
        }
        
        const scanData = {
          timestamp: new Date().toISOString(),
          bib: cleanBib,
          name: runnerName,
          checkpoint: checkpoint
        };
        
        // Mark as processed to prevent duplicates
        markScanAsProcessed(cleanBib, checkpoint);
        
        // Add to recent scans
        storeRecentScan(scanData);
        
        if (isOnline) {
          submitScanToSheet(scanData)
            .then(function(success) {
              if (success) {
                showMessage(`Recorded: ${runnerName} (${cleanBib})`);
              } else {
                showMessage('Error submitting scan. Storing offline.', true);
                storeScanOffline(scanData);
              }
            })
            .catch(function(error) {
              logDebug('Error submitting scan: ' + error);
              showMessage('Error submitting scan. Storing offline.', true);
              storeScanOffline(scanData);
            });
        } else {
          storeScanOffline(scanData);
          showMessage(`Stored offline: ${runnerName} (${cleanBib})`);
        }
      }
      
      // Store a recent scan
      function storeRecentScan(scanData) {
        try {
          // Add to memory first
          if (recentScans.length >= 10) {
            recentScans.pop(); // Remove the oldest scan
          }
          recentScans.unshift(scanData); // Add new scan at the beginning
          updateRecentScansUI();
          
          // Store in localStorage
          localStorage.setItem('recentScans', JSON.stringify(recentScans));
        } catch (error) {
          logDebug('Error storing recent scan: ' + error);
        }
      }
      
      // Store scan offline
      function storeScanOffline(scanData) {
        try {
          // Check if we already have a pending upload for this bib+checkpoint
          const existingIndex = pendingUploads.findIndex(
            scan => scan.bib === scanData.bib && scan.checkpoint === scanData.checkpoint
          );
          
          if (existingIndex >= 0) {
            // Replace the existing entry with the newer one
            pendingUploads[existingIndex] = scanData;
          } else {
            // Add to memory
            pendingUploads.push(scanData);
          }
          
          updatePendingUploadsUI();
          
          // Store in localStorage
          localStorage.setItem('pendingUploads', JSON.stringify(pendingUploads));
          logDebug(`Stored scan offline: ${scanData.bib} - ${scanData.name}`);
        } catch (error) {
          logDebug('Error storing scan offline: ' + error);
        }
      }
      
      // Submit scan to Google Sheet
      function submitScanToSheet(scanData) {
        return new Promise(function(resolve, reject) {
          // Format data for the script - IMPORTANT: This matches the expected format in the Apps Script
          const formData = new FormData();
          formData.append('action', 'recordScan');
          
          // Create a data object in the format expected by the Apps Script
          const data = {
            timestamp: new Date().toISOString(),
            bibNumber: scanData.bib,
            runnerName: scanData.name,
            checkpoint: scanData.checkpoint,
            replaceExisting: true // Tell the server to replace any existing entry
          };
          
          // Append the data as a JSON string
          formData.append('data', JSON.stringify(data));
          
          logDebug(`Submitting scan to sheet: ${scanData.bib} - ${scanData.name} at ${scanData.checkpoint}`);
          
          // Send data to the Google Apps Script
          fetch(APPS_SCRIPT_URL, {
            method: 'POST',
            body: formData,
            mode: 'no-cors' // Required for Google Apps Script
          })
          .then(() => {
            // Since we're using no-cors, we can't actually check the response
            // We'll just assume it worked
            logDebug('Scan submitted successfully');
            resolve(true);
          })
          .catch(error => {
            logDebug('Error submitting scan: ' + error);
            reject(error);
          });
        });
      }
      
      // Upload pending scans
      function uploadPendingScans(forceUpload = false) {
        if (pendingUploads.length === 0 || (!isOnline && !forceUpload)) return;
        
        logDebug(`Attempting to upload ${pendingUploads.length} pending scans`);
        
        // Create a copy of the pending uploads to process
        const uploadsToProcess = [...pendingUploads];
        let successCount = 0;
        let failCount = 0;
        
        // Process each scan
        const promises = uploadsToProcess.map(scanData => {
          return submitScanToSheet(scanData)
            .then(success => {
              if (success) {
                successCount++;
                return { success: true, data: scanData };
              } else {
                failCount++;
                return { success: false, data: scanData };
              }
            })
            .catch(() => {
              failCount++;
              return { success: false, data: scanData };
            });
        });
        
        Promise.all(promises).then(results => {
          // Filter out successful uploads
          const failedUploads = results
            .filter(result => !result.success)
            .map(result => result.data);
          
          // Update pendingUploads with only failed uploads
          pendingUploads = failedUploads;
          localStorage.setItem('pendingUploads', JSON.stringify(pendingUploads));
          updatePendingUploadsUI();
          
          if (successCount > 0) {
            if (failCount > 0) {
              showMessage(`Uploaded ${successCount} scans, ${failCount} failed and will retry later.`);
            } else {
              showMessage(`All ${successCount} pending scans uploaded successfully!`);
            }
          }
          
          logDebug(`Upload complete: ${successCount} successful, ${failCount} failed`);
        });
      }
      
      // Handle manual bib submission
      manualSubmitButton.addEventListener('click', function() {
        const bib = bibInput.value.trim();
        
        if (!bib) {
          showMessage('Please enter a bib number', true);
          return;
        }
        
        // Find runner in our loaded data
        const runnerName = runnersData[bib];
        
        if (!runnerName) {
          showMessage(`No runner found with bib ${bib}`, true);
          return;
        }
        
        // Check if we should process this scan (not a duplicate or is newer)
        if (!shouldProcessScan(bib, checkpoint)) {
          showMessage(`Already recorded: ${runnerName} (${bib})`, false);
          bibInput.value = '';
          return;
        }
        
        const scanData = {
          timestamp: new Date().toISOString(),
          bib: bib,
          name: runnerName,
          checkpoint: checkpoint
        };
        
        // Mark as processed to prevent duplicates
        markScanAsProcessed(bib, checkpoint);
        
        // Play beep sound and vibrate
        playBeep();
        vibrate();
        
        // Add to recent scans
        storeRecentScan(scanData);
        
        if (isOnline) {
          submitScanToSheet(scanData)
            .then(function(success) {
              if (success) {
                showMessage(`Recorded: ${runnerName} (${bib})`);
                // Clear form
                bibInput.value = '';
              } else {
                showMessage('Error submitting entry. Storing offline.', true);
                storeScanOffline(scanData);
                // Still clear the form
                bibInput.value = '';
              }
            })
            .catch(function(error) {
              logDebug('Error submitting manual entry: ' + error);
              showMessage('Error submitting entry. Storing offline.', true);
              storeScanOffline(scanData);
              // Still clear the form
              bibInput.value = '';
            });
        } else {
          storeScanOffline(scanData);
          showMessage(`Stored offline: ${runnerName} (${bib})`);
          // Clear form
          bibInput.value = '';
        }
      });
      
      // Show message
      function showMessage(text, isError = false) {
        messageDisplay.textContent = text;
        messageDisplay.classList.remove('hidden');
        
        if (isError) {
          messageDisplay.classList.remove('success-message');
          messageDisplay.classList.add('error-message');
        } else {
          messageDisplay.classList.remove('error-message');
          messageDisplay.classList.add('success-message');
        }
        
        // Hide message after 3 seconds
        setTimeout(function() {
          messageDisplay.classList.add('hidden');
        }, 3000);
      }
      
      // Initialize the app
      init();
    });
  </script>
</body>
</html>
